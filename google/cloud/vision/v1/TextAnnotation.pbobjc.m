// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/cloud/vision/v1/text_annotation.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import <googleapis/TextAnnotation.pbobjc.h>
#import <googleapis/Annotations.pbobjc.h>
#import <googleapis/Geometry.pbobjc.h>
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - GCVNTextAnnotationRoot

@implementation GCVNTextAnnotationRoot

+ (GPBExtensionRegistry*)extensionRegistry {
  // This is called by +initialize so there is no need to worry
  // about thread safety and initialization of registry.
  static GPBExtensionRegistry* registry = nil;
  if (!registry) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    registry = [[GPBExtensionRegistry alloc] init];
    // Merge in the imports (direct or indirect) that defined extensions.
    [registry addExtensions:[AnnotationsRoot extensionRegistry]];
  }
  return registry;
}

@end

#pragma mark - GCVNTextAnnotationRoot_FileDescriptor

static GPBFileDescriptor *GCVNTextAnnotationRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"google.cloud.vision.v1"
                                                 objcPrefix:@"GCVN"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - GCVNTextAnnotation

@implementation GCVNTextAnnotation

@dynamic pagesArray, pagesArray_Count;
@dynamic text;

typedef struct GCVNTextAnnotation__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *pagesArray;
  NSString *text;
} GCVNTextAnnotation__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pagesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GCVNPage),
        .number = GCVNTextAnnotation_FieldNumber_PagesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GCVNTextAnnotation__storage_, pagesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "text",
        .dataTypeSpecific.className = NULL,
        .number = GCVNTextAnnotation_FieldNumber_Text,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCVNTextAnnotation__storage_, text),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCVNTextAnnotation class]
                                     rootClass:[GCVNTextAnnotationRoot class]
                                          file:GCVNTextAnnotationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCVNTextAnnotation__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GCVNTextAnnotation_DetectedLanguage

@implementation GCVNTextAnnotation_DetectedLanguage

@dynamic languageCode;
@dynamic confidence;

typedef struct GCVNTextAnnotation_DetectedLanguage__storage_ {
  uint32_t _has_storage_[1];
  float confidence;
  NSString *languageCode;
} GCVNTextAnnotation_DetectedLanguage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "languageCode",
        .dataTypeSpecific.className = NULL,
        .number = GCVNTextAnnotation_DetectedLanguage_FieldNumber_LanguageCode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCVNTextAnnotation_DetectedLanguage__storage_, languageCode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "confidence",
        .dataTypeSpecific.className = NULL,
        .number = GCVNTextAnnotation_DetectedLanguage_FieldNumber_Confidence,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GCVNTextAnnotation_DetectedLanguage__storage_, confidence),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCVNTextAnnotation_DetectedLanguage class]
                                     rootClass:[GCVNTextAnnotationRoot class]
                                          file:GCVNTextAnnotationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCVNTextAnnotation_DetectedLanguage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(GCVNTextAnnotation)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GCVNTextAnnotation_DetectedBreak

@implementation GCVNTextAnnotation_DetectedBreak

@dynamic type;
@dynamic isPrefix;

typedef struct GCVNTextAnnotation_DetectedBreak__storage_ {
  uint32_t _has_storage_[1];
  GCVNTextAnnotation_DetectedBreak_BreakType type;
} GCVNTextAnnotation_DetectedBreak__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = GCVNTextAnnotation_DetectedBreak_BreakType_EnumDescriptor,
        .number = GCVNTextAnnotation_DetectedBreak_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCVNTextAnnotation_DetectedBreak__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "isPrefix",
        .dataTypeSpecific.className = NULL,
        .number = GCVNTextAnnotation_DetectedBreak_FieldNumber_IsPrefix,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCVNTextAnnotation_DetectedBreak class]
                                     rootClass:[GCVNTextAnnotationRoot class]
                                          file:GCVNTextAnnotationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCVNTextAnnotation_DetectedBreak__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(GCVNTextAnnotation)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t GCVNTextAnnotation_DetectedBreak_Type_RawValue(GCVNTextAnnotation_DetectedBreak *message) {
  GPBDescriptor *descriptor = [GCVNTextAnnotation_DetectedBreak descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GCVNTextAnnotation_DetectedBreak_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetGCVNTextAnnotation_DetectedBreak_Type_RawValue(GCVNTextAnnotation_DetectedBreak *message, int32_t value) {
  GPBDescriptor *descriptor = [GCVNTextAnnotation_DetectedBreak descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GCVNTextAnnotation_DetectedBreak_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum GCVNTextAnnotation_DetectedBreak_BreakType

GPBEnumDescriptor *GCVNTextAnnotation_DetectedBreak_BreakType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Unknown\000Space\000SureSpace\000EolSureSpace\000Hyp"
        "hen\000LineBreak\000";
    static const int32_t values[] = {
        GCVNTextAnnotation_DetectedBreak_BreakType_Unknown,
        GCVNTextAnnotation_DetectedBreak_BreakType_Space,
        GCVNTextAnnotation_DetectedBreak_BreakType_SureSpace,
        GCVNTextAnnotation_DetectedBreak_BreakType_EolSureSpace,
        GCVNTextAnnotation_DetectedBreak_BreakType_Hyphen,
        GCVNTextAnnotation_DetectedBreak_BreakType_LineBreak,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(GCVNTextAnnotation_DetectedBreak_BreakType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:GCVNTextAnnotation_DetectedBreak_BreakType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL GCVNTextAnnotation_DetectedBreak_BreakType_IsValidValue(int32_t value__) {
  switch (value__) {
    case GCVNTextAnnotation_DetectedBreak_BreakType_Unknown:
    case GCVNTextAnnotation_DetectedBreak_BreakType_Space:
    case GCVNTextAnnotation_DetectedBreak_BreakType_SureSpace:
    case GCVNTextAnnotation_DetectedBreak_BreakType_EolSureSpace:
    case GCVNTextAnnotation_DetectedBreak_BreakType_Hyphen:
    case GCVNTextAnnotation_DetectedBreak_BreakType_LineBreak:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - GCVNTextAnnotation_TextProperty

@implementation GCVNTextAnnotation_TextProperty

@dynamic detectedLanguagesArray, detectedLanguagesArray_Count;
@dynamic hasDetectedBreak, detectedBreak;

typedef struct GCVNTextAnnotation_TextProperty__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *detectedLanguagesArray;
  GCVNTextAnnotation_DetectedBreak *detectedBreak;
} GCVNTextAnnotation_TextProperty__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "detectedLanguagesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GCVNTextAnnotation_DetectedLanguage),
        .number = GCVNTextAnnotation_TextProperty_FieldNumber_DetectedLanguagesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GCVNTextAnnotation_TextProperty__storage_, detectedLanguagesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "detectedBreak",
        .dataTypeSpecific.className = GPBStringifySymbol(GCVNTextAnnotation_DetectedBreak),
        .number = GCVNTextAnnotation_TextProperty_FieldNumber_DetectedBreak,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCVNTextAnnotation_TextProperty__storage_, detectedBreak),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCVNTextAnnotation_TextProperty class]
                                     rootClass:[GCVNTextAnnotationRoot class]
                                          file:GCVNTextAnnotationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCVNTextAnnotation_TextProperty__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(GCVNTextAnnotation)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GCVNPage

@implementation GCVNPage

@dynamic hasProperty, property;
@dynamic width;
@dynamic height;
@dynamic blocksArray, blocksArray_Count;
@dynamic confidence;

typedef struct GCVNPage__storage_ {
  uint32_t _has_storage_[1];
  int32_t width;
  int32_t height;
  float confidence;
  GCVNTextAnnotation_TextProperty *property;
  NSMutableArray *blocksArray;
} GCVNPage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "property",
        .dataTypeSpecific.className = GPBStringifySymbol(GCVNTextAnnotation_TextProperty),
        .number = GCVNPage_FieldNumber_Property,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCVNPage__storage_, property),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "width",
        .dataTypeSpecific.className = NULL,
        .number = GCVNPage_FieldNumber_Width,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GCVNPage__storage_, width),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "height",
        .dataTypeSpecific.className = NULL,
        .number = GCVNPage_FieldNumber_Height,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GCVNPage__storage_, height),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "blocksArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GCVNBlock),
        .number = GCVNPage_FieldNumber_BlocksArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GCVNPage__storage_, blocksArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "confidence",
        .dataTypeSpecific.className = NULL,
        .number = GCVNPage_FieldNumber_Confidence,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GCVNPage__storage_, confidence),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCVNPage class]
                                     rootClass:[GCVNTextAnnotationRoot class]
                                          file:GCVNTextAnnotationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCVNPage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GCVNBlock

@implementation GCVNBlock

@dynamic hasProperty, property;
@dynamic hasBoundingBox, boundingBox;
@dynamic paragraphsArray, paragraphsArray_Count;
@dynamic blockType;
@dynamic confidence;

typedef struct GCVNBlock__storage_ {
  uint32_t _has_storage_[1];
  GCVNBlock_BlockType blockType;
  float confidence;
  GCVNTextAnnotation_TextProperty *property;
  GCVNBoundingPoly *boundingBox;
  NSMutableArray *paragraphsArray;
} GCVNBlock__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "property",
        .dataTypeSpecific.className = GPBStringifySymbol(GCVNTextAnnotation_TextProperty),
        .number = GCVNBlock_FieldNumber_Property,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCVNBlock__storage_, property),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "boundingBox",
        .dataTypeSpecific.className = GPBStringifySymbol(GCVNBoundingPoly),
        .number = GCVNBlock_FieldNumber_BoundingBox,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GCVNBlock__storage_, boundingBox),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "paragraphsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GCVNParagraph),
        .number = GCVNBlock_FieldNumber_ParagraphsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GCVNBlock__storage_, paragraphsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "blockType",
        .dataTypeSpecific.enumDescFunc = GCVNBlock_BlockType_EnumDescriptor,
        .number = GCVNBlock_FieldNumber_BlockType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GCVNBlock__storage_, blockType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "confidence",
        .dataTypeSpecific.className = NULL,
        .number = GCVNBlock_FieldNumber_Confidence,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GCVNBlock__storage_, confidence),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCVNBlock class]
                                     rootClass:[GCVNTextAnnotationRoot class]
                                          file:GCVNTextAnnotationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCVNBlock__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t GCVNBlock_BlockType_RawValue(GCVNBlock *message) {
  GPBDescriptor *descriptor = [GCVNBlock descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GCVNBlock_FieldNumber_BlockType];
  return GPBGetMessageInt32Field(message, field);
}

void SetGCVNBlock_BlockType_RawValue(GCVNBlock *message, int32_t value) {
  GPBDescriptor *descriptor = [GCVNBlock descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GCVNBlock_FieldNumber_BlockType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum GCVNBlock_BlockType

GPBEnumDescriptor *GCVNBlock_BlockType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Unknown\000Text\000Table\000Picture\000Ruler\000Barcode"
        "\000";
    static const int32_t values[] = {
        GCVNBlock_BlockType_Unknown,
        GCVNBlock_BlockType_Text,
        GCVNBlock_BlockType_Table,
        GCVNBlock_BlockType_Picture,
        GCVNBlock_BlockType_Ruler,
        GCVNBlock_BlockType_Barcode,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(GCVNBlock_BlockType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:GCVNBlock_BlockType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL GCVNBlock_BlockType_IsValidValue(int32_t value__) {
  switch (value__) {
    case GCVNBlock_BlockType_Unknown:
    case GCVNBlock_BlockType_Text:
    case GCVNBlock_BlockType_Table:
    case GCVNBlock_BlockType_Picture:
    case GCVNBlock_BlockType_Ruler:
    case GCVNBlock_BlockType_Barcode:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - GCVNParagraph

@implementation GCVNParagraph

@dynamic hasProperty, property;
@dynamic hasBoundingBox, boundingBox;
@dynamic wordsArray, wordsArray_Count;
@dynamic confidence;

typedef struct GCVNParagraph__storage_ {
  uint32_t _has_storage_[1];
  float confidence;
  GCVNTextAnnotation_TextProperty *property;
  GCVNBoundingPoly *boundingBox;
  NSMutableArray *wordsArray;
} GCVNParagraph__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "property",
        .dataTypeSpecific.className = GPBStringifySymbol(GCVNTextAnnotation_TextProperty),
        .number = GCVNParagraph_FieldNumber_Property,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCVNParagraph__storage_, property),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "boundingBox",
        .dataTypeSpecific.className = GPBStringifySymbol(GCVNBoundingPoly),
        .number = GCVNParagraph_FieldNumber_BoundingBox,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GCVNParagraph__storage_, boundingBox),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "wordsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GCVNWord),
        .number = GCVNParagraph_FieldNumber_WordsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GCVNParagraph__storage_, wordsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "confidence",
        .dataTypeSpecific.className = NULL,
        .number = GCVNParagraph_FieldNumber_Confidence,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GCVNParagraph__storage_, confidence),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCVNParagraph class]
                                     rootClass:[GCVNTextAnnotationRoot class]
                                          file:GCVNTextAnnotationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCVNParagraph__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GCVNWord

@implementation GCVNWord

@dynamic hasProperty, property;
@dynamic hasBoundingBox, boundingBox;
@dynamic symbolsArray, symbolsArray_Count;
@dynamic confidence;

typedef struct GCVNWord__storage_ {
  uint32_t _has_storage_[1];
  float confidence;
  GCVNTextAnnotation_TextProperty *property;
  GCVNBoundingPoly *boundingBox;
  NSMutableArray *symbolsArray;
} GCVNWord__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "property",
        .dataTypeSpecific.className = GPBStringifySymbol(GCVNTextAnnotation_TextProperty),
        .number = GCVNWord_FieldNumber_Property,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCVNWord__storage_, property),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "boundingBox",
        .dataTypeSpecific.className = GPBStringifySymbol(GCVNBoundingPoly),
        .number = GCVNWord_FieldNumber_BoundingBox,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GCVNWord__storage_, boundingBox),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "symbolsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GCVNSymbol),
        .number = GCVNWord_FieldNumber_SymbolsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GCVNWord__storage_, symbolsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "confidence",
        .dataTypeSpecific.className = NULL,
        .number = GCVNWord_FieldNumber_Confidence,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GCVNWord__storage_, confidence),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCVNWord class]
                                     rootClass:[GCVNTextAnnotationRoot class]
                                          file:GCVNTextAnnotationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCVNWord__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GCVNSymbol

@implementation GCVNSymbol

@dynamic hasProperty, property;
@dynamic hasBoundingBox, boundingBox;
@dynamic text;
@dynamic confidence;

typedef struct GCVNSymbol__storage_ {
  uint32_t _has_storage_[1];
  float confidence;
  GCVNTextAnnotation_TextProperty *property;
  GCVNBoundingPoly *boundingBox;
  NSString *text;
} GCVNSymbol__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "property",
        .dataTypeSpecific.className = GPBStringifySymbol(GCVNTextAnnotation_TextProperty),
        .number = GCVNSymbol_FieldNumber_Property,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCVNSymbol__storage_, property),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "boundingBox",
        .dataTypeSpecific.className = GPBStringifySymbol(GCVNBoundingPoly),
        .number = GCVNSymbol_FieldNumber_BoundingBox,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GCVNSymbol__storage_, boundingBox),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "text",
        .dataTypeSpecific.className = NULL,
        .number = GCVNSymbol_FieldNumber_Text,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GCVNSymbol__storage_, text),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "confidence",
        .dataTypeSpecific.className = NULL,
        .number = GCVNSymbol_FieldNumber_Confidence,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GCVNSymbol__storage_, confidence),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCVNSymbol class]
                                     rootClass:[GCVNTextAnnotationRoot class]
                                          file:GCVNTextAnnotationRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCVNSymbol__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
