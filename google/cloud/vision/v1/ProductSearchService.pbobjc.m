// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/cloud/vision/v1/product_search_service.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import <googleapis/ProductSearchService.pbobjc.h>
#import <googleapis/Annotations.pbobjc.h>
#import <googleapis/Geometry.pbobjc.h>
#import <googleapis/Operations.pbobjc.h>
#import <googleapis/Status.pbobjc.h>
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"

#pragma mark - GCVNProductSearchServiceRoot

@implementation GCVNProductSearchServiceRoot

+ (GPBExtensionRegistry*)extensionRegistry {
  // This is called by +initialize so there is no need to worry
  // about thread safety and initialization of registry.
  static GPBExtensionRegistry* registry = nil;
  if (!registry) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    registry = [[GPBExtensionRegistry alloc] init];
    // Merge in the imports (direct or indirect) that defined extensions.
    [registry addExtensions:[AnnotationsRoot extensionRegistry]];
  }
  return registry;
}

@end

#pragma mark - GCVNProductSearchServiceRoot_FileDescriptor

static GPBFileDescriptor *GCVNProductSearchServiceRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"google.cloud.vision.v1"
                                                 objcPrefix:@"GCVN"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - GCVNProduct

@implementation GCVNProduct

@dynamic name;
@dynamic displayName;
@dynamic description_p;
@dynamic productCategory;
@dynamic productLabelsArray, productLabelsArray_Count;

typedef struct GCVNProduct__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  NSString *displayName;
  NSString *description_p;
  NSString *productCategory;
  NSMutableArray *productLabelsArray;
} GCVNProduct__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = GCVNProduct_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCVNProduct__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "displayName",
        .dataTypeSpecific.className = NULL,
        .number = GCVNProduct_FieldNumber_DisplayName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GCVNProduct__storage_, displayName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "description_p",
        .dataTypeSpecific.className = NULL,
        .number = GCVNProduct_FieldNumber_Description_p,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GCVNProduct__storage_, description_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "productCategory",
        .dataTypeSpecific.className = NULL,
        .number = GCVNProduct_FieldNumber_ProductCategory,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GCVNProduct__storage_, productCategory),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "productLabelsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GCVNProduct_KeyValue),
        .number = GCVNProduct_FieldNumber_ProductLabelsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GCVNProduct__storage_, productLabelsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCVNProduct class]
                                     rootClass:[GCVNProductSearchServiceRoot class]
                                          file:GCVNProductSearchServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCVNProduct__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GCVNProduct_KeyValue

@implementation GCVNProduct_KeyValue

@dynamic key;
@dynamic value;

typedef struct GCVNProduct_KeyValue__storage_ {
  uint32_t _has_storage_[1];
  NSString *key;
  NSString *value;
} GCVNProduct_KeyValue__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.className = NULL,
        .number = GCVNProduct_KeyValue_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCVNProduct_KeyValue__storage_, key),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = GCVNProduct_KeyValue_FieldNumber_Value,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GCVNProduct_KeyValue__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCVNProduct_KeyValue class]
                                     rootClass:[GCVNProductSearchServiceRoot class]
                                          file:GCVNProductSearchServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCVNProduct_KeyValue__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(GCVNProduct)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GCVNProductSet

@implementation GCVNProductSet

@dynamic name;
@dynamic displayName;
@dynamic hasIndexTime, indexTime;
@dynamic hasIndexError, indexError;

typedef struct GCVNProductSet__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  NSString *displayName;
  GPBTimestamp *indexTime;
  Status *indexError;
} GCVNProductSet__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = GCVNProductSet_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCVNProductSet__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "displayName",
        .dataTypeSpecific.className = NULL,
        .number = GCVNProductSet_FieldNumber_DisplayName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GCVNProductSet__storage_, displayName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "indexTime",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBTimestamp),
        .number = GCVNProductSet_FieldNumber_IndexTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GCVNProductSet__storage_, indexTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "indexError",
        .dataTypeSpecific.className = GPBStringifySymbol(Status),
        .number = GCVNProductSet_FieldNumber_IndexError,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GCVNProductSet__storage_, indexError),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCVNProductSet class]
                                     rootClass:[GCVNProductSearchServiceRoot class]
                                          file:GCVNProductSearchServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCVNProductSet__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GCVNReferenceImage

@implementation GCVNReferenceImage

@dynamic name;
@dynamic uri;
@dynamic boundingPolysArray, boundingPolysArray_Count;

typedef struct GCVNReferenceImage__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  NSString *uri;
  NSMutableArray *boundingPolysArray;
} GCVNReferenceImage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = GCVNReferenceImage_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCVNReferenceImage__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "uri",
        .dataTypeSpecific.className = NULL,
        .number = GCVNReferenceImage_FieldNumber_Uri,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GCVNReferenceImage__storage_, uri),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "boundingPolysArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GCVNBoundingPoly),
        .number = GCVNReferenceImage_FieldNumber_BoundingPolysArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GCVNReferenceImage__storage_, boundingPolysArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCVNReferenceImage class]
                                     rootClass:[GCVNProductSearchServiceRoot class]
                                          file:GCVNProductSearchServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCVNReferenceImage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GCVNCreateProductRequest

@implementation GCVNCreateProductRequest

@dynamic parent;
@dynamic hasProduct, product;
@dynamic productId;

typedef struct GCVNCreateProductRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *parent;
  GCVNProduct *product;
  NSString *productId;
} GCVNCreateProductRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "parent",
        .dataTypeSpecific.className = NULL,
        .number = GCVNCreateProductRequest_FieldNumber_Parent,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCVNCreateProductRequest__storage_, parent),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "product",
        .dataTypeSpecific.className = GPBStringifySymbol(GCVNProduct),
        .number = GCVNCreateProductRequest_FieldNumber_Product,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GCVNCreateProductRequest__storage_, product),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "productId",
        .dataTypeSpecific.className = NULL,
        .number = GCVNCreateProductRequest_FieldNumber_ProductId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GCVNCreateProductRequest__storage_, productId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCVNCreateProductRequest class]
                                     rootClass:[GCVNProductSearchServiceRoot class]
                                          file:GCVNProductSearchServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCVNCreateProductRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GCVNListProductsRequest

@implementation GCVNListProductsRequest

@dynamic parent;
@dynamic pageSize;
@dynamic pageToken;

typedef struct GCVNListProductsRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t pageSize;
  NSString *parent;
  NSString *pageToken;
} GCVNListProductsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "parent",
        .dataTypeSpecific.className = NULL,
        .number = GCVNListProductsRequest_FieldNumber_Parent,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCVNListProductsRequest__storage_, parent),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pageSize",
        .dataTypeSpecific.className = NULL,
        .number = GCVNListProductsRequest_FieldNumber_PageSize,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GCVNListProductsRequest__storage_, pageSize),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "pageToken",
        .dataTypeSpecific.className = NULL,
        .number = GCVNListProductsRequest_FieldNumber_PageToken,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GCVNListProductsRequest__storage_, pageToken),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCVNListProductsRequest class]
                                     rootClass:[GCVNProductSearchServiceRoot class]
                                          file:GCVNProductSearchServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCVNListProductsRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GCVNListProductsResponse

@implementation GCVNListProductsResponse

@dynamic productsArray, productsArray_Count;
@dynamic nextPageToken;

typedef struct GCVNListProductsResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *productsArray;
  NSString *nextPageToken;
} GCVNListProductsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "productsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GCVNProduct),
        .number = GCVNListProductsResponse_FieldNumber_ProductsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GCVNListProductsResponse__storage_, productsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "nextPageToken",
        .dataTypeSpecific.className = NULL,
        .number = GCVNListProductsResponse_FieldNumber_NextPageToken,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCVNListProductsResponse__storage_, nextPageToken),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCVNListProductsResponse class]
                                     rootClass:[GCVNProductSearchServiceRoot class]
                                          file:GCVNProductSearchServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCVNListProductsResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GCVNGetProductRequest

@implementation GCVNGetProductRequest

@dynamic name;

typedef struct GCVNGetProductRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
} GCVNGetProductRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = GCVNGetProductRequest_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCVNGetProductRequest__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCVNGetProductRequest class]
                                     rootClass:[GCVNProductSearchServiceRoot class]
                                          file:GCVNProductSearchServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCVNGetProductRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GCVNUpdateProductRequest

@implementation GCVNUpdateProductRequest

@dynamic hasProduct, product;
@dynamic hasUpdateMask, updateMask;

typedef struct GCVNUpdateProductRequest__storage_ {
  uint32_t _has_storage_[1];
  GCVNProduct *product;
  GPBFieldMask *updateMask;
} GCVNUpdateProductRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "product",
        .dataTypeSpecific.className = GPBStringifySymbol(GCVNProduct),
        .number = GCVNUpdateProductRequest_FieldNumber_Product,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCVNUpdateProductRequest__storage_, product),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "updateMask",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBFieldMask),
        .number = GCVNUpdateProductRequest_FieldNumber_UpdateMask,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GCVNUpdateProductRequest__storage_, updateMask),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCVNUpdateProductRequest class]
                                     rootClass:[GCVNProductSearchServiceRoot class]
                                          file:GCVNProductSearchServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCVNUpdateProductRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GCVNDeleteProductRequest

@implementation GCVNDeleteProductRequest

@dynamic name;

typedef struct GCVNDeleteProductRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
} GCVNDeleteProductRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = GCVNDeleteProductRequest_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCVNDeleteProductRequest__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCVNDeleteProductRequest class]
                                     rootClass:[GCVNProductSearchServiceRoot class]
                                          file:GCVNProductSearchServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCVNDeleteProductRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GCVNCreateProductSetRequest

@implementation GCVNCreateProductSetRequest

@dynamic parent;
@dynamic hasProductSet, productSet;
@dynamic productSetId;

typedef struct GCVNCreateProductSetRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *parent;
  GCVNProductSet *productSet;
  NSString *productSetId;
} GCVNCreateProductSetRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "parent",
        .dataTypeSpecific.className = NULL,
        .number = GCVNCreateProductSetRequest_FieldNumber_Parent,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCVNCreateProductSetRequest__storage_, parent),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "productSet",
        .dataTypeSpecific.className = GPBStringifySymbol(GCVNProductSet),
        .number = GCVNCreateProductSetRequest_FieldNumber_ProductSet,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GCVNCreateProductSetRequest__storage_, productSet),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "productSetId",
        .dataTypeSpecific.className = NULL,
        .number = GCVNCreateProductSetRequest_FieldNumber_ProductSetId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GCVNCreateProductSetRequest__storage_, productSetId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCVNCreateProductSetRequest class]
                                     rootClass:[GCVNProductSearchServiceRoot class]
                                          file:GCVNProductSearchServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCVNCreateProductSetRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GCVNListProductSetsRequest

@implementation GCVNListProductSetsRequest

@dynamic parent;
@dynamic pageSize;
@dynamic pageToken;

typedef struct GCVNListProductSetsRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t pageSize;
  NSString *parent;
  NSString *pageToken;
} GCVNListProductSetsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "parent",
        .dataTypeSpecific.className = NULL,
        .number = GCVNListProductSetsRequest_FieldNumber_Parent,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCVNListProductSetsRequest__storage_, parent),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pageSize",
        .dataTypeSpecific.className = NULL,
        .number = GCVNListProductSetsRequest_FieldNumber_PageSize,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GCVNListProductSetsRequest__storage_, pageSize),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "pageToken",
        .dataTypeSpecific.className = NULL,
        .number = GCVNListProductSetsRequest_FieldNumber_PageToken,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GCVNListProductSetsRequest__storage_, pageToken),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCVNListProductSetsRequest class]
                                     rootClass:[GCVNProductSearchServiceRoot class]
                                          file:GCVNProductSearchServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCVNListProductSetsRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GCVNListProductSetsResponse

@implementation GCVNListProductSetsResponse

@dynamic productSetsArray, productSetsArray_Count;
@dynamic nextPageToken;

typedef struct GCVNListProductSetsResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *productSetsArray;
  NSString *nextPageToken;
} GCVNListProductSetsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "productSetsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GCVNProductSet),
        .number = GCVNListProductSetsResponse_FieldNumber_ProductSetsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GCVNListProductSetsResponse__storage_, productSetsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "nextPageToken",
        .dataTypeSpecific.className = NULL,
        .number = GCVNListProductSetsResponse_FieldNumber_NextPageToken,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCVNListProductSetsResponse__storage_, nextPageToken),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCVNListProductSetsResponse class]
                                     rootClass:[GCVNProductSearchServiceRoot class]
                                          file:GCVNProductSearchServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCVNListProductSetsResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GCVNGetProductSetRequest

@implementation GCVNGetProductSetRequest

@dynamic name;

typedef struct GCVNGetProductSetRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
} GCVNGetProductSetRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = GCVNGetProductSetRequest_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCVNGetProductSetRequest__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCVNGetProductSetRequest class]
                                     rootClass:[GCVNProductSearchServiceRoot class]
                                          file:GCVNProductSearchServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCVNGetProductSetRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GCVNUpdateProductSetRequest

@implementation GCVNUpdateProductSetRequest

@dynamic hasProductSet, productSet;
@dynamic hasUpdateMask, updateMask;

typedef struct GCVNUpdateProductSetRequest__storage_ {
  uint32_t _has_storage_[1];
  GCVNProductSet *productSet;
  GPBFieldMask *updateMask;
} GCVNUpdateProductSetRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "productSet",
        .dataTypeSpecific.className = GPBStringifySymbol(GCVNProductSet),
        .number = GCVNUpdateProductSetRequest_FieldNumber_ProductSet,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCVNUpdateProductSetRequest__storage_, productSet),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "updateMask",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBFieldMask),
        .number = GCVNUpdateProductSetRequest_FieldNumber_UpdateMask,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GCVNUpdateProductSetRequest__storage_, updateMask),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCVNUpdateProductSetRequest class]
                                     rootClass:[GCVNProductSearchServiceRoot class]
                                          file:GCVNProductSearchServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCVNUpdateProductSetRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GCVNDeleteProductSetRequest

@implementation GCVNDeleteProductSetRequest

@dynamic name;

typedef struct GCVNDeleteProductSetRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
} GCVNDeleteProductSetRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = GCVNDeleteProductSetRequest_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCVNDeleteProductSetRequest__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCVNDeleteProductSetRequest class]
                                     rootClass:[GCVNProductSearchServiceRoot class]
                                          file:GCVNProductSearchServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCVNDeleteProductSetRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GCVNCreateReferenceImageRequest

@implementation GCVNCreateReferenceImageRequest

@dynamic parent;
@dynamic hasReferenceImage, referenceImage;
@dynamic referenceImageId;

typedef struct GCVNCreateReferenceImageRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *parent;
  GCVNReferenceImage *referenceImage;
  NSString *referenceImageId;
} GCVNCreateReferenceImageRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "parent",
        .dataTypeSpecific.className = NULL,
        .number = GCVNCreateReferenceImageRequest_FieldNumber_Parent,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCVNCreateReferenceImageRequest__storage_, parent),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "referenceImage",
        .dataTypeSpecific.className = GPBStringifySymbol(GCVNReferenceImage),
        .number = GCVNCreateReferenceImageRequest_FieldNumber_ReferenceImage,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GCVNCreateReferenceImageRequest__storage_, referenceImage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "referenceImageId",
        .dataTypeSpecific.className = NULL,
        .number = GCVNCreateReferenceImageRequest_FieldNumber_ReferenceImageId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GCVNCreateReferenceImageRequest__storage_, referenceImageId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCVNCreateReferenceImageRequest class]
                                     rootClass:[GCVNProductSearchServiceRoot class]
                                          file:GCVNProductSearchServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCVNCreateReferenceImageRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GCVNListReferenceImagesRequest

@implementation GCVNListReferenceImagesRequest

@dynamic parent;
@dynamic pageSize;
@dynamic pageToken;

typedef struct GCVNListReferenceImagesRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t pageSize;
  NSString *parent;
  NSString *pageToken;
} GCVNListReferenceImagesRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "parent",
        .dataTypeSpecific.className = NULL,
        .number = GCVNListReferenceImagesRequest_FieldNumber_Parent,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCVNListReferenceImagesRequest__storage_, parent),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pageSize",
        .dataTypeSpecific.className = NULL,
        .number = GCVNListReferenceImagesRequest_FieldNumber_PageSize,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GCVNListReferenceImagesRequest__storage_, pageSize),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "pageToken",
        .dataTypeSpecific.className = NULL,
        .number = GCVNListReferenceImagesRequest_FieldNumber_PageToken,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GCVNListReferenceImagesRequest__storage_, pageToken),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCVNListReferenceImagesRequest class]
                                     rootClass:[GCVNProductSearchServiceRoot class]
                                          file:GCVNProductSearchServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCVNListReferenceImagesRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GCVNListReferenceImagesResponse

@implementation GCVNListReferenceImagesResponse

@dynamic referenceImagesArray, referenceImagesArray_Count;
@dynamic pageSize;
@dynamic nextPageToken;

typedef struct GCVNListReferenceImagesResponse__storage_ {
  uint32_t _has_storage_[1];
  int32_t pageSize;
  NSMutableArray *referenceImagesArray;
  NSString *nextPageToken;
} GCVNListReferenceImagesResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "referenceImagesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GCVNReferenceImage),
        .number = GCVNListReferenceImagesResponse_FieldNumber_ReferenceImagesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GCVNListReferenceImagesResponse__storage_, referenceImagesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "pageSize",
        .dataTypeSpecific.className = NULL,
        .number = GCVNListReferenceImagesResponse_FieldNumber_PageSize,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCVNListReferenceImagesResponse__storage_, pageSize),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "nextPageToken",
        .dataTypeSpecific.className = NULL,
        .number = GCVNListReferenceImagesResponse_FieldNumber_NextPageToken,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GCVNListReferenceImagesResponse__storage_, nextPageToken),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCVNListReferenceImagesResponse class]
                                     rootClass:[GCVNProductSearchServiceRoot class]
                                          file:GCVNProductSearchServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCVNListReferenceImagesResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GCVNGetReferenceImageRequest

@implementation GCVNGetReferenceImageRequest

@dynamic name;

typedef struct GCVNGetReferenceImageRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
} GCVNGetReferenceImageRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = GCVNGetReferenceImageRequest_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCVNGetReferenceImageRequest__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCVNGetReferenceImageRequest class]
                                     rootClass:[GCVNProductSearchServiceRoot class]
                                          file:GCVNProductSearchServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCVNGetReferenceImageRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GCVNDeleteReferenceImageRequest

@implementation GCVNDeleteReferenceImageRequest

@dynamic name;

typedef struct GCVNDeleteReferenceImageRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
} GCVNDeleteReferenceImageRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = GCVNDeleteReferenceImageRequest_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCVNDeleteReferenceImageRequest__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCVNDeleteReferenceImageRequest class]
                                     rootClass:[GCVNProductSearchServiceRoot class]
                                          file:GCVNProductSearchServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCVNDeleteReferenceImageRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GCVNAddProductToProductSetRequest

@implementation GCVNAddProductToProductSetRequest

@dynamic name;
@dynamic product;

typedef struct GCVNAddProductToProductSetRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  NSString *product;
} GCVNAddProductToProductSetRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = GCVNAddProductToProductSetRequest_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCVNAddProductToProductSetRequest__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "product",
        .dataTypeSpecific.className = NULL,
        .number = GCVNAddProductToProductSetRequest_FieldNumber_Product,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GCVNAddProductToProductSetRequest__storage_, product),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCVNAddProductToProductSetRequest class]
                                     rootClass:[GCVNProductSearchServiceRoot class]
                                          file:GCVNProductSearchServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCVNAddProductToProductSetRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GCVNRemoveProductFromProductSetRequest

@implementation GCVNRemoveProductFromProductSetRequest

@dynamic name;
@dynamic product;

typedef struct GCVNRemoveProductFromProductSetRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  NSString *product;
} GCVNRemoveProductFromProductSetRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = GCVNRemoveProductFromProductSetRequest_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCVNRemoveProductFromProductSetRequest__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "product",
        .dataTypeSpecific.className = NULL,
        .number = GCVNRemoveProductFromProductSetRequest_FieldNumber_Product,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GCVNRemoveProductFromProductSetRequest__storage_, product),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCVNRemoveProductFromProductSetRequest class]
                                     rootClass:[GCVNProductSearchServiceRoot class]
                                          file:GCVNProductSearchServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCVNRemoveProductFromProductSetRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GCVNListProductsInProductSetRequest

@implementation GCVNListProductsInProductSetRequest

@dynamic name;
@dynamic pageSize;
@dynamic pageToken;

typedef struct GCVNListProductsInProductSetRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t pageSize;
  NSString *name;
  NSString *pageToken;
} GCVNListProductsInProductSetRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = GCVNListProductsInProductSetRequest_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCVNListProductsInProductSetRequest__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pageSize",
        .dataTypeSpecific.className = NULL,
        .number = GCVNListProductsInProductSetRequest_FieldNumber_PageSize,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GCVNListProductsInProductSetRequest__storage_, pageSize),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "pageToken",
        .dataTypeSpecific.className = NULL,
        .number = GCVNListProductsInProductSetRequest_FieldNumber_PageToken,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GCVNListProductsInProductSetRequest__storage_, pageToken),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCVNListProductsInProductSetRequest class]
                                     rootClass:[GCVNProductSearchServiceRoot class]
                                          file:GCVNProductSearchServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCVNListProductsInProductSetRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GCVNListProductsInProductSetResponse

@implementation GCVNListProductsInProductSetResponse

@dynamic productsArray, productsArray_Count;
@dynamic nextPageToken;

typedef struct GCVNListProductsInProductSetResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *productsArray;
  NSString *nextPageToken;
} GCVNListProductsInProductSetResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "productsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GCVNProduct),
        .number = GCVNListProductsInProductSetResponse_FieldNumber_ProductsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GCVNListProductsInProductSetResponse__storage_, productsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "nextPageToken",
        .dataTypeSpecific.className = NULL,
        .number = GCVNListProductsInProductSetResponse_FieldNumber_NextPageToken,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCVNListProductsInProductSetResponse__storage_, nextPageToken),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCVNListProductsInProductSetResponse class]
                                     rootClass:[GCVNProductSearchServiceRoot class]
                                          file:GCVNProductSearchServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCVNListProductsInProductSetResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GCVNImportProductSetsGcsSource

@implementation GCVNImportProductSetsGcsSource

@dynamic csvFileUri;

typedef struct GCVNImportProductSetsGcsSource__storage_ {
  uint32_t _has_storage_[1];
  NSString *csvFileUri;
} GCVNImportProductSetsGcsSource__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "csvFileUri",
        .dataTypeSpecific.className = NULL,
        .number = GCVNImportProductSetsGcsSource_FieldNumber_CsvFileUri,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCVNImportProductSetsGcsSource__storage_, csvFileUri),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCVNImportProductSetsGcsSource class]
                                     rootClass:[GCVNProductSearchServiceRoot class]
                                          file:GCVNProductSearchServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCVNImportProductSetsGcsSource__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GCVNImportProductSetsInputConfig

@implementation GCVNImportProductSetsInputConfig

@dynamic sourceOneOfCase;
@dynamic gcsSource;

typedef struct GCVNImportProductSetsInputConfig__storage_ {
  uint32_t _has_storage_[2];
  GCVNImportProductSetsGcsSource *gcsSource;
} GCVNImportProductSetsInputConfig__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "gcsSource",
        .dataTypeSpecific.className = GPBStringifySymbol(GCVNImportProductSetsGcsSource),
        .number = GCVNImportProductSetsInputConfig_FieldNumber_GcsSource,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(GCVNImportProductSetsInputConfig__storage_, gcsSource),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCVNImportProductSetsInputConfig class]
                                     rootClass:[GCVNProductSearchServiceRoot class]
                                          file:GCVNProductSearchServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCVNImportProductSetsInputConfig__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "source",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void GCVNImportProductSetsInputConfig_ClearSourceOneOfCase(GCVNImportProductSetsInputConfig *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - GCVNImportProductSetsRequest

@implementation GCVNImportProductSetsRequest

@dynamic parent;
@dynamic hasInputConfig, inputConfig;

typedef struct GCVNImportProductSetsRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *parent;
  GCVNImportProductSetsInputConfig *inputConfig;
} GCVNImportProductSetsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "parent",
        .dataTypeSpecific.className = NULL,
        .number = GCVNImportProductSetsRequest_FieldNumber_Parent,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCVNImportProductSetsRequest__storage_, parent),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "inputConfig",
        .dataTypeSpecific.className = GPBStringifySymbol(GCVNImportProductSetsInputConfig),
        .number = GCVNImportProductSetsRequest_FieldNumber_InputConfig,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GCVNImportProductSetsRequest__storage_, inputConfig),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCVNImportProductSetsRequest class]
                                     rootClass:[GCVNProductSearchServiceRoot class]
                                          file:GCVNProductSearchServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCVNImportProductSetsRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GCVNImportProductSetsResponse

@implementation GCVNImportProductSetsResponse

@dynamic referenceImagesArray, referenceImagesArray_Count;
@dynamic statusesArray, statusesArray_Count;

typedef struct GCVNImportProductSetsResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *referenceImagesArray;
  NSMutableArray *statusesArray;
} GCVNImportProductSetsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "referenceImagesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GCVNReferenceImage),
        .number = GCVNImportProductSetsResponse_FieldNumber_ReferenceImagesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GCVNImportProductSetsResponse__storage_, referenceImagesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "statusesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Status),
        .number = GCVNImportProductSetsResponse_FieldNumber_StatusesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GCVNImportProductSetsResponse__storage_, statusesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCVNImportProductSetsResponse class]
                                     rootClass:[GCVNProductSearchServiceRoot class]
                                          file:GCVNProductSearchServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCVNImportProductSetsResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GCVNBatchOperationMetadata

@implementation GCVNBatchOperationMetadata

@dynamic state;
@dynamic hasSubmitTime, submitTime;
@dynamic hasEndTime, endTime;

typedef struct GCVNBatchOperationMetadata__storage_ {
  uint32_t _has_storage_[1];
  GCVNBatchOperationMetadata_State state;
  GPBTimestamp *submitTime;
  GPBTimestamp *endTime;
} GCVNBatchOperationMetadata__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "state",
        .dataTypeSpecific.enumDescFunc = GCVNBatchOperationMetadata_State_EnumDescriptor,
        .number = GCVNBatchOperationMetadata_FieldNumber_State,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCVNBatchOperationMetadata__storage_, state),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "submitTime",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBTimestamp),
        .number = GCVNBatchOperationMetadata_FieldNumber_SubmitTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GCVNBatchOperationMetadata__storage_, submitTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "endTime",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBTimestamp),
        .number = GCVNBatchOperationMetadata_FieldNumber_EndTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GCVNBatchOperationMetadata__storage_, endTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCVNBatchOperationMetadata class]
                                     rootClass:[GCVNProductSearchServiceRoot class]
                                          file:GCVNProductSearchServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCVNBatchOperationMetadata__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t GCVNBatchOperationMetadata_State_RawValue(GCVNBatchOperationMetadata *message) {
  GPBDescriptor *descriptor = [GCVNBatchOperationMetadata descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GCVNBatchOperationMetadata_FieldNumber_State];
  return GPBGetMessageInt32Field(message, field);
}

void SetGCVNBatchOperationMetadata_State_RawValue(GCVNBatchOperationMetadata *message, int32_t value) {
  GPBDescriptor *descriptor = [GCVNBatchOperationMetadata descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GCVNBatchOperationMetadata_FieldNumber_State];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum GCVNBatchOperationMetadata_State

GPBEnumDescriptor *GCVNBatchOperationMetadata_State_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "StateUnspecified\000Processing\000Successful\000F"
        "ailed\000Cancelled\000";
    static const int32_t values[] = {
        GCVNBatchOperationMetadata_State_StateUnspecified,
        GCVNBatchOperationMetadata_State_Processing,
        GCVNBatchOperationMetadata_State_Successful,
        GCVNBatchOperationMetadata_State_Failed,
        GCVNBatchOperationMetadata_State_Cancelled,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(GCVNBatchOperationMetadata_State)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:GCVNBatchOperationMetadata_State_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL GCVNBatchOperationMetadata_State_IsValidValue(int32_t value__) {
  switch (value__) {
    case GCVNBatchOperationMetadata_State_StateUnspecified:
    case GCVNBatchOperationMetadata_State_Processing:
    case GCVNBatchOperationMetadata_State_Successful:
    case GCVNBatchOperationMetadata_State_Failed:
    case GCVNBatchOperationMetadata_State_Cancelled:
      return YES;
    default:
      return NO;
  }
}


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
