// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/cloud/vision/v1/image_annotator.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import <googleapis/ImageAnnotator.pbobjc.h>
#import <googleapis/Annotations.pbobjc.h>
#import <googleapis/Geometry.pbobjc.h>
#import <googleapis/ProductSearch.pbobjc.h>
#import <googleapis/TextAnnotation.pbobjc.h>
#import <googleapis/WebDetection.pbobjc.h>
#import <googleapis/Operations.pbobjc.h>
#import <googleapis/Status.pbobjc.h>
#import <googleapis/Color.pbobjc.h>
#import <googleapis/Latlng.pbobjc.h>
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - GCVNImageAnnotatorRoot

@implementation GCVNImageAnnotatorRoot

+ (GPBExtensionRegistry*)extensionRegistry {
  // This is called by +initialize so there is no need to worry
  // about thread safety and initialization of registry.
  static GPBExtensionRegistry* registry = nil;
  if (!registry) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    registry = [[GPBExtensionRegistry alloc] init];
    // Merge in the imports (direct or indirect) that defined extensions.
    [registry addExtensions:[AnnotationsRoot extensionRegistry]];
  }
  return registry;
}

@end

#pragma mark - GCVNImageAnnotatorRoot_FileDescriptor

static GPBFileDescriptor *GCVNImageAnnotatorRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"google.cloud.vision.v1"
                                                 objcPrefix:@"GCVN"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum GCVNLikelihood

GPBEnumDescriptor *GCVNLikelihood_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Unknown\000VeryUnlikely\000Unlikely\000Possible\000L"
        "ikely\000VeryLikely\000";
    static const int32_t values[] = {
        GCVNLikelihood_Unknown,
        GCVNLikelihood_VeryUnlikely,
        GCVNLikelihood_Unlikely,
        GCVNLikelihood_Possible,
        GCVNLikelihood_Likely,
        GCVNLikelihood_VeryLikely,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(GCVNLikelihood)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:GCVNLikelihood_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL GCVNLikelihood_IsValidValue(int32_t value__) {
  switch (value__) {
    case GCVNLikelihood_Unknown:
    case GCVNLikelihood_VeryUnlikely:
    case GCVNLikelihood_Unlikely:
    case GCVNLikelihood_Possible:
    case GCVNLikelihood_Likely:
    case GCVNLikelihood_VeryLikely:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - GCVNFeature

@implementation GCVNFeature

@dynamic type;
@dynamic maxResults;
@dynamic model;

typedef struct GCVNFeature__storage_ {
  uint32_t _has_storage_[1];
  GCVNFeature_Type type;
  int32_t maxResults;
  NSString *model;
} GCVNFeature__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = GCVNFeature_Type_EnumDescriptor,
        .number = GCVNFeature_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCVNFeature__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "maxResults",
        .dataTypeSpecific.className = NULL,
        .number = GCVNFeature_FieldNumber_MaxResults,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GCVNFeature__storage_, maxResults),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "model",
        .dataTypeSpecific.className = NULL,
        .number = GCVNFeature_FieldNumber_Model,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GCVNFeature__storage_, model),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCVNFeature class]
                                     rootClass:[GCVNImageAnnotatorRoot class]
                                          file:GCVNImageAnnotatorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCVNFeature__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t GCVNFeature_Type_RawValue(GCVNFeature *message) {
  GPBDescriptor *descriptor = [GCVNFeature descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GCVNFeature_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetGCVNFeature_Type_RawValue(GCVNFeature *message, int32_t value) {
  GPBDescriptor *descriptor = [GCVNFeature descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GCVNFeature_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum GCVNFeature_Type

GPBEnumDescriptor *GCVNFeature_Type_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "TypeUnspecified\000FaceDetection\000LandmarkDe"
        "tection\000LogoDetection\000LabelDetection\000Tex"
        "tDetection\000DocumentTextDetection\000SafeSea"
        "rchDetection\000ImageProperties\000CropHints\000W"
        "ebDetection\000ProductSearch\000ObjectLocaliza"
        "tion\000";
    static const int32_t values[] = {
        GCVNFeature_Type_TypeUnspecified,
        GCVNFeature_Type_FaceDetection,
        GCVNFeature_Type_LandmarkDetection,
        GCVNFeature_Type_LogoDetection,
        GCVNFeature_Type_LabelDetection,
        GCVNFeature_Type_TextDetection,
        GCVNFeature_Type_DocumentTextDetection,
        GCVNFeature_Type_SafeSearchDetection,
        GCVNFeature_Type_ImageProperties,
        GCVNFeature_Type_CropHints,
        GCVNFeature_Type_WebDetection,
        GCVNFeature_Type_ProductSearch,
        GCVNFeature_Type_ObjectLocalization,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(GCVNFeature_Type)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:GCVNFeature_Type_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL GCVNFeature_Type_IsValidValue(int32_t value__) {
  switch (value__) {
    case GCVNFeature_Type_TypeUnspecified:
    case GCVNFeature_Type_FaceDetection:
    case GCVNFeature_Type_LandmarkDetection:
    case GCVNFeature_Type_LogoDetection:
    case GCVNFeature_Type_LabelDetection:
    case GCVNFeature_Type_TextDetection:
    case GCVNFeature_Type_DocumentTextDetection:
    case GCVNFeature_Type_SafeSearchDetection:
    case GCVNFeature_Type_ImageProperties:
    case GCVNFeature_Type_CropHints:
    case GCVNFeature_Type_WebDetection:
    case GCVNFeature_Type_ProductSearch:
    case GCVNFeature_Type_ObjectLocalization:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - GCVNImageSource

@implementation GCVNImageSource

@dynamic gcsImageUri;
@dynamic imageUri;

typedef struct GCVNImageSource__storage_ {
  uint32_t _has_storage_[1];
  NSString *gcsImageUri;
  NSString *imageUri;
} GCVNImageSource__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "gcsImageUri",
        .dataTypeSpecific.className = NULL,
        .number = GCVNImageSource_FieldNumber_GcsImageUri,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCVNImageSource__storage_, gcsImageUri),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "imageUri",
        .dataTypeSpecific.className = NULL,
        .number = GCVNImageSource_FieldNumber_ImageUri,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GCVNImageSource__storage_, imageUri),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCVNImageSource class]
                                     rootClass:[GCVNImageAnnotatorRoot class]
                                          file:GCVNImageAnnotatorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCVNImageSource__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GCVNImage

@implementation GCVNImage

@dynamic content;
@dynamic hasSource, source;

typedef struct GCVNImage__storage_ {
  uint32_t _has_storage_[1];
  NSData *content;
  GCVNImageSource *source;
} GCVNImage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = GCVNImage_FieldNumber_Content,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCVNImage__storage_, content),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "source",
        .dataTypeSpecific.className = GPBStringifySymbol(GCVNImageSource),
        .number = GCVNImage_FieldNumber_Source,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GCVNImage__storage_, source),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCVNImage class]
                                     rootClass:[GCVNImageAnnotatorRoot class]
                                          file:GCVNImageAnnotatorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCVNImage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GCVNFaceAnnotation

@implementation GCVNFaceAnnotation

@dynamic hasBoundingPoly, boundingPoly;
@dynamic hasFdBoundingPoly, fdBoundingPoly;
@dynamic landmarksArray, landmarksArray_Count;
@dynamic rollAngle;
@dynamic panAngle;
@dynamic tiltAngle;
@dynamic detectionConfidence;
@dynamic landmarkingConfidence;
@dynamic joyLikelihood;
@dynamic sorrowLikelihood;
@dynamic angerLikelihood;
@dynamic surpriseLikelihood;
@dynamic underExposedLikelihood;
@dynamic blurredLikelihood;
@dynamic headwearLikelihood;

typedef struct GCVNFaceAnnotation__storage_ {
  uint32_t _has_storage_[1];
  float rollAngle;
  float panAngle;
  float tiltAngle;
  float detectionConfidence;
  float landmarkingConfidence;
  GCVNLikelihood joyLikelihood;
  GCVNLikelihood sorrowLikelihood;
  GCVNLikelihood angerLikelihood;
  GCVNLikelihood surpriseLikelihood;
  GCVNLikelihood underExposedLikelihood;
  GCVNLikelihood blurredLikelihood;
  GCVNLikelihood headwearLikelihood;
  GCVNBoundingPoly *boundingPoly;
  GCVNBoundingPoly *fdBoundingPoly;
  NSMutableArray *landmarksArray;
} GCVNFaceAnnotation__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "boundingPoly",
        .dataTypeSpecific.className = GPBStringifySymbol(GCVNBoundingPoly),
        .number = GCVNFaceAnnotation_FieldNumber_BoundingPoly,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCVNFaceAnnotation__storage_, boundingPoly),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "fdBoundingPoly",
        .dataTypeSpecific.className = GPBStringifySymbol(GCVNBoundingPoly),
        .number = GCVNFaceAnnotation_FieldNumber_FdBoundingPoly,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GCVNFaceAnnotation__storage_, fdBoundingPoly),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "landmarksArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GCVNFaceAnnotation_Landmark),
        .number = GCVNFaceAnnotation_FieldNumber_LandmarksArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GCVNFaceAnnotation__storage_, landmarksArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "rollAngle",
        .dataTypeSpecific.className = NULL,
        .number = GCVNFaceAnnotation_FieldNumber_RollAngle,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GCVNFaceAnnotation__storage_, rollAngle),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "panAngle",
        .dataTypeSpecific.className = NULL,
        .number = GCVNFaceAnnotation_FieldNumber_PanAngle,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GCVNFaceAnnotation__storage_, panAngle),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "tiltAngle",
        .dataTypeSpecific.className = NULL,
        .number = GCVNFaceAnnotation_FieldNumber_TiltAngle,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GCVNFaceAnnotation__storage_, tiltAngle),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "detectionConfidence",
        .dataTypeSpecific.className = NULL,
        .number = GCVNFaceAnnotation_FieldNumber_DetectionConfidence,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(GCVNFaceAnnotation__storage_, detectionConfidence),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "landmarkingConfidence",
        .dataTypeSpecific.className = NULL,
        .number = GCVNFaceAnnotation_FieldNumber_LandmarkingConfidence,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(GCVNFaceAnnotation__storage_, landmarkingConfidence),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "joyLikelihood",
        .dataTypeSpecific.enumDescFunc = GCVNLikelihood_EnumDescriptor,
        .number = GCVNFaceAnnotation_FieldNumber_JoyLikelihood,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(GCVNFaceAnnotation__storage_, joyLikelihood),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "sorrowLikelihood",
        .dataTypeSpecific.enumDescFunc = GCVNLikelihood_EnumDescriptor,
        .number = GCVNFaceAnnotation_FieldNumber_SorrowLikelihood,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(GCVNFaceAnnotation__storage_, sorrowLikelihood),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "angerLikelihood",
        .dataTypeSpecific.enumDescFunc = GCVNLikelihood_EnumDescriptor,
        .number = GCVNFaceAnnotation_FieldNumber_AngerLikelihood,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(GCVNFaceAnnotation__storage_, angerLikelihood),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "surpriseLikelihood",
        .dataTypeSpecific.enumDescFunc = GCVNLikelihood_EnumDescriptor,
        .number = GCVNFaceAnnotation_FieldNumber_SurpriseLikelihood,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(GCVNFaceAnnotation__storage_, surpriseLikelihood),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "underExposedLikelihood",
        .dataTypeSpecific.enumDescFunc = GCVNLikelihood_EnumDescriptor,
        .number = GCVNFaceAnnotation_FieldNumber_UnderExposedLikelihood,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(GCVNFaceAnnotation__storage_, underExposedLikelihood),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "blurredLikelihood",
        .dataTypeSpecific.enumDescFunc = GCVNLikelihood_EnumDescriptor,
        .number = GCVNFaceAnnotation_FieldNumber_BlurredLikelihood,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(GCVNFaceAnnotation__storage_, blurredLikelihood),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "headwearLikelihood",
        .dataTypeSpecific.enumDescFunc = GCVNLikelihood_EnumDescriptor,
        .number = GCVNFaceAnnotation_FieldNumber_HeadwearLikelihood,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(GCVNFaceAnnotation__storage_, headwearLikelihood),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCVNFaceAnnotation class]
                                     rootClass:[GCVNImageAnnotatorRoot class]
                                          file:GCVNImageAnnotatorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCVNFaceAnnotation__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t GCVNFaceAnnotation_JoyLikelihood_RawValue(GCVNFaceAnnotation *message) {
  GPBDescriptor *descriptor = [GCVNFaceAnnotation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GCVNFaceAnnotation_FieldNumber_JoyLikelihood];
  return GPBGetMessageInt32Field(message, field);
}

void SetGCVNFaceAnnotation_JoyLikelihood_RawValue(GCVNFaceAnnotation *message, int32_t value) {
  GPBDescriptor *descriptor = [GCVNFaceAnnotation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GCVNFaceAnnotation_FieldNumber_JoyLikelihood];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t GCVNFaceAnnotation_SorrowLikelihood_RawValue(GCVNFaceAnnotation *message) {
  GPBDescriptor *descriptor = [GCVNFaceAnnotation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GCVNFaceAnnotation_FieldNumber_SorrowLikelihood];
  return GPBGetMessageInt32Field(message, field);
}

void SetGCVNFaceAnnotation_SorrowLikelihood_RawValue(GCVNFaceAnnotation *message, int32_t value) {
  GPBDescriptor *descriptor = [GCVNFaceAnnotation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GCVNFaceAnnotation_FieldNumber_SorrowLikelihood];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t GCVNFaceAnnotation_AngerLikelihood_RawValue(GCVNFaceAnnotation *message) {
  GPBDescriptor *descriptor = [GCVNFaceAnnotation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GCVNFaceAnnotation_FieldNumber_AngerLikelihood];
  return GPBGetMessageInt32Field(message, field);
}

void SetGCVNFaceAnnotation_AngerLikelihood_RawValue(GCVNFaceAnnotation *message, int32_t value) {
  GPBDescriptor *descriptor = [GCVNFaceAnnotation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GCVNFaceAnnotation_FieldNumber_AngerLikelihood];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t GCVNFaceAnnotation_SurpriseLikelihood_RawValue(GCVNFaceAnnotation *message) {
  GPBDescriptor *descriptor = [GCVNFaceAnnotation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GCVNFaceAnnotation_FieldNumber_SurpriseLikelihood];
  return GPBGetMessageInt32Field(message, field);
}

void SetGCVNFaceAnnotation_SurpriseLikelihood_RawValue(GCVNFaceAnnotation *message, int32_t value) {
  GPBDescriptor *descriptor = [GCVNFaceAnnotation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GCVNFaceAnnotation_FieldNumber_SurpriseLikelihood];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t GCVNFaceAnnotation_UnderExposedLikelihood_RawValue(GCVNFaceAnnotation *message) {
  GPBDescriptor *descriptor = [GCVNFaceAnnotation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GCVNFaceAnnotation_FieldNumber_UnderExposedLikelihood];
  return GPBGetMessageInt32Field(message, field);
}

void SetGCVNFaceAnnotation_UnderExposedLikelihood_RawValue(GCVNFaceAnnotation *message, int32_t value) {
  GPBDescriptor *descriptor = [GCVNFaceAnnotation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GCVNFaceAnnotation_FieldNumber_UnderExposedLikelihood];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t GCVNFaceAnnotation_BlurredLikelihood_RawValue(GCVNFaceAnnotation *message) {
  GPBDescriptor *descriptor = [GCVNFaceAnnotation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GCVNFaceAnnotation_FieldNumber_BlurredLikelihood];
  return GPBGetMessageInt32Field(message, field);
}

void SetGCVNFaceAnnotation_BlurredLikelihood_RawValue(GCVNFaceAnnotation *message, int32_t value) {
  GPBDescriptor *descriptor = [GCVNFaceAnnotation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GCVNFaceAnnotation_FieldNumber_BlurredLikelihood];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t GCVNFaceAnnotation_HeadwearLikelihood_RawValue(GCVNFaceAnnotation *message) {
  GPBDescriptor *descriptor = [GCVNFaceAnnotation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GCVNFaceAnnotation_FieldNumber_HeadwearLikelihood];
  return GPBGetMessageInt32Field(message, field);
}

void SetGCVNFaceAnnotation_HeadwearLikelihood_RawValue(GCVNFaceAnnotation *message, int32_t value) {
  GPBDescriptor *descriptor = [GCVNFaceAnnotation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GCVNFaceAnnotation_FieldNumber_HeadwearLikelihood];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - GCVNFaceAnnotation_Landmark

@implementation GCVNFaceAnnotation_Landmark

@dynamic type;
@dynamic hasPosition, position;

typedef struct GCVNFaceAnnotation_Landmark__storage_ {
  uint32_t _has_storage_[1];
  GCVNFaceAnnotation_Landmark_Type type;
  GCVNPosition *position;
} GCVNFaceAnnotation_Landmark__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = GCVNFaceAnnotation_Landmark_Type_EnumDescriptor,
        .number = GCVNFaceAnnotation_Landmark_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCVNFaceAnnotation_Landmark__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "position",
        .dataTypeSpecific.className = GPBStringifySymbol(GCVNPosition),
        .number = GCVNFaceAnnotation_Landmark_FieldNumber_Position,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GCVNFaceAnnotation_Landmark__storage_, position),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCVNFaceAnnotation_Landmark class]
                                     rootClass:[GCVNImageAnnotatorRoot class]
                                          file:GCVNImageAnnotatorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCVNFaceAnnotation_Landmark__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(GCVNFaceAnnotation)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t GCVNFaceAnnotation_Landmark_Type_RawValue(GCVNFaceAnnotation_Landmark *message) {
  GPBDescriptor *descriptor = [GCVNFaceAnnotation_Landmark descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GCVNFaceAnnotation_Landmark_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetGCVNFaceAnnotation_Landmark_Type_RawValue(GCVNFaceAnnotation_Landmark *message, int32_t value) {
  GPBDescriptor *descriptor = [GCVNFaceAnnotation_Landmark descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GCVNFaceAnnotation_Landmark_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum GCVNFaceAnnotation_Landmark_Type

GPBEnumDescriptor *GCVNFaceAnnotation_Landmark_Type_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "UnknownLandmark\000LeftEye\000RightEye\000LeftOfL"
        "eftEyebrow\000RightOfLeftEyebrow\000LeftOfRigh"
        "tEyebrow\000RightOfRightEyebrow\000MidpointBet"
        "weenEyes\000NoseTip\000UpperLip\000LowerLip\000Mouth"
        "Left\000MouthRight\000MouthCenter\000NoseBottomRi"
        "ght\000NoseBottomLeft\000NoseBottomCenter\000Left"
        "EyeTopBoundary\000LeftEyeRightCorner\000LeftEy"
        "eBottomBoundary\000LeftEyeLeftCorner\000RightE"
        "yeTopBoundary\000RightEyeRightCorner\000RightE"
        "yeBottomBoundary\000RightEyeLeftCorner\000Left"
        "EyebrowUpperMidpoint\000RightEyebrowUpperMi"
        "dpoint\000LeftEarTragion\000RightEarTragion\000Le"
        "ftEyePupil\000RightEyePupil\000ForeheadGlabell"
        "a\000ChinGnathion\000ChinLeftGonion\000ChinRightG"
        "onion\000";
    static const int32_t values[] = {
        GCVNFaceAnnotation_Landmark_Type_UnknownLandmark,
        GCVNFaceAnnotation_Landmark_Type_LeftEye,
        GCVNFaceAnnotation_Landmark_Type_RightEye,
        GCVNFaceAnnotation_Landmark_Type_LeftOfLeftEyebrow,
        GCVNFaceAnnotation_Landmark_Type_RightOfLeftEyebrow,
        GCVNFaceAnnotation_Landmark_Type_LeftOfRightEyebrow,
        GCVNFaceAnnotation_Landmark_Type_RightOfRightEyebrow,
        GCVNFaceAnnotation_Landmark_Type_MidpointBetweenEyes,
        GCVNFaceAnnotation_Landmark_Type_NoseTip,
        GCVNFaceAnnotation_Landmark_Type_UpperLip,
        GCVNFaceAnnotation_Landmark_Type_LowerLip,
        GCVNFaceAnnotation_Landmark_Type_MouthLeft,
        GCVNFaceAnnotation_Landmark_Type_MouthRight,
        GCVNFaceAnnotation_Landmark_Type_MouthCenter,
        GCVNFaceAnnotation_Landmark_Type_NoseBottomRight,
        GCVNFaceAnnotation_Landmark_Type_NoseBottomLeft,
        GCVNFaceAnnotation_Landmark_Type_NoseBottomCenter,
        GCVNFaceAnnotation_Landmark_Type_LeftEyeTopBoundary,
        GCVNFaceAnnotation_Landmark_Type_LeftEyeRightCorner,
        GCVNFaceAnnotation_Landmark_Type_LeftEyeBottomBoundary,
        GCVNFaceAnnotation_Landmark_Type_LeftEyeLeftCorner,
        GCVNFaceAnnotation_Landmark_Type_RightEyeTopBoundary,
        GCVNFaceAnnotation_Landmark_Type_RightEyeRightCorner,
        GCVNFaceAnnotation_Landmark_Type_RightEyeBottomBoundary,
        GCVNFaceAnnotation_Landmark_Type_RightEyeLeftCorner,
        GCVNFaceAnnotation_Landmark_Type_LeftEyebrowUpperMidpoint,
        GCVNFaceAnnotation_Landmark_Type_RightEyebrowUpperMidpoint,
        GCVNFaceAnnotation_Landmark_Type_LeftEarTragion,
        GCVNFaceAnnotation_Landmark_Type_RightEarTragion,
        GCVNFaceAnnotation_Landmark_Type_LeftEyePupil,
        GCVNFaceAnnotation_Landmark_Type_RightEyePupil,
        GCVNFaceAnnotation_Landmark_Type_ForeheadGlabella,
        GCVNFaceAnnotation_Landmark_Type_ChinGnathion,
        GCVNFaceAnnotation_Landmark_Type_ChinLeftGonion,
        GCVNFaceAnnotation_Landmark_Type_ChinRightGonion,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(GCVNFaceAnnotation_Landmark_Type)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:GCVNFaceAnnotation_Landmark_Type_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL GCVNFaceAnnotation_Landmark_Type_IsValidValue(int32_t value__) {
  switch (value__) {
    case GCVNFaceAnnotation_Landmark_Type_UnknownLandmark:
    case GCVNFaceAnnotation_Landmark_Type_LeftEye:
    case GCVNFaceAnnotation_Landmark_Type_RightEye:
    case GCVNFaceAnnotation_Landmark_Type_LeftOfLeftEyebrow:
    case GCVNFaceAnnotation_Landmark_Type_RightOfLeftEyebrow:
    case GCVNFaceAnnotation_Landmark_Type_LeftOfRightEyebrow:
    case GCVNFaceAnnotation_Landmark_Type_RightOfRightEyebrow:
    case GCVNFaceAnnotation_Landmark_Type_MidpointBetweenEyes:
    case GCVNFaceAnnotation_Landmark_Type_NoseTip:
    case GCVNFaceAnnotation_Landmark_Type_UpperLip:
    case GCVNFaceAnnotation_Landmark_Type_LowerLip:
    case GCVNFaceAnnotation_Landmark_Type_MouthLeft:
    case GCVNFaceAnnotation_Landmark_Type_MouthRight:
    case GCVNFaceAnnotation_Landmark_Type_MouthCenter:
    case GCVNFaceAnnotation_Landmark_Type_NoseBottomRight:
    case GCVNFaceAnnotation_Landmark_Type_NoseBottomLeft:
    case GCVNFaceAnnotation_Landmark_Type_NoseBottomCenter:
    case GCVNFaceAnnotation_Landmark_Type_LeftEyeTopBoundary:
    case GCVNFaceAnnotation_Landmark_Type_LeftEyeRightCorner:
    case GCVNFaceAnnotation_Landmark_Type_LeftEyeBottomBoundary:
    case GCVNFaceAnnotation_Landmark_Type_LeftEyeLeftCorner:
    case GCVNFaceAnnotation_Landmark_Type_RightEyeTopBoundary:
    case GCVNFaceAnnotation_Landmark_Type_RightEyeRightCorner:
    case GCVNFaceAnnotation_Landmark_Type_RightEyeBottomBoundary:
    case GCVNFaceAnnotation_Landmark_Type_RightEyeLeftCorner:
    case GCVNFaceAnnotation_Landmark_Type_LeftEyebrowUpperMidpoint:
    case GCVNFaceAnnotation_Landmark_Type_RightEyebrowUpperMidpoint:
    case GCVNFaceAnnotation_Landmark_Type_LeftEarTragion:
    case GCVNFaceAnnotation_Landmark_Type_RightEarTragion:
    case GCVNFaceAnnotation_Landmark_Type_LeftEyePupil:
    case GCVNFaceAnnotation_Landmark_Type_RightEyePupil:
    case GCVNFaceAnnotation_Landmark_Type_ForeheadGlabella:
    case GCVNFaceAnnotation_Landmark_Type_ChinGnathion:
    case GCVNFaceAnnotation_Landmark_Type_ChinLeftGonion:
    case GCVNFaceAnnotation_Landmark_Type_ChinRightGonion:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - GCVNLocationInfo

@implementation GCVNLocationInfo

@dynamic hasLatLng, latLng;

typedef struct GCVNLocationInfo__storage_ {
  uint32_t _has_storage_[1];
  GTPLatLng *latLng;
} GCVNLocationInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "latLng",
        .dataTypeSpecific.className = GPBStringifySymbol(GTPLatLng),
        .number = GCVNLocationInfo_FieldNumber_LatLng,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCVNLocationInfo__storage_, latLng),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCVNLocationInfo class]
                                     rootClass:[GCVNImageAnnotatorRoot class]
                                          file:GCVNImageAnnotatorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCVNLocationInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GCVNProperty

@implementation GCVNProperty

@dynamic name;
@dynamic value;
@dynamic uint64Value;

typedef struct GCVNProperty__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  NSString *value;
  uint64_t uint64Value;
} GCVNProperty__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = GCVNProperty_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCVNProperty__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = GCVNProperty_FieldNumber_Value,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GCVNProperty__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "uint64Value",
        .dataTypeSpecific.className = NULL,
        .number = GCVNProperty_FieldNumber_Uint64Value,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GCVNProperty__storage_, uint64Value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCVNProperty class]
                                     rootClass:[GCVNImageAnnotatorRoot class]
                                          file:GCVNImageAnnotatorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCVNProperty__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GCVNEntityAnnotation

@implementation GCVNEntityAnnotation

@dynamic mid;
@dynamic locale;
@dynamic description_p;
@dynamic score;
@dynamic confidence;
@dynamic topicality;
@dynamic hasBoundingPoly, boundingPoly;
@dynamic locationsArray, locationsArray_Count;
@dynamic propertiesArray, propertiesArray_Count;

typedef struct GCVNEntityAnnotation__storage_ {
  uint32_t _has_storage_[1];
  float score;
  float confidence;
  float topicality;
  NSString *mid;
  NSString *locale;
  NSString *description_p;
  GCVNBoundingPoly *boundingPoly;
  NSMutableArray *locationsArray;
  NSMutableArray *propertiesArray;
} GCVNEntityAnnotation__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "mid",
        .dataTypeSpecific.className = NULL,
        .number = GCVNEntityAnnotation_FieldNumber_Mid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCVNEntityAnnotation__storage_, mid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "locale",
        .dataTypeSpecific.className = NULL,
        .number = GCVNEntityAnnotation_FieldNumber_Locale,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GCVNEntityAnnotation__storage_, locale),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "description_p",
        .dataTypeSpecific.className = NULL,
        .number = GCVNEntityAnnotation_FieldNumber_Description_p,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GCVNEntityAnnotation__storage_, description_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "score",
        .dataTypeSpecific.className = NULL,
        .number = GCVNEntityAnnotation_FieldNumber_Score,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GCVNEntityAnnotation__storage_, score),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "confidence",
        .dataTypeSpecific.className = NULL,
        .number = GCVNEntityAnnotation_FieldNumber_Confidence,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GCVNEntityAnnotation__storage_, confidence),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "topicality",
        .dataTypeSpecific.className = NULL,
        .number = GCVNEntityAnnotation_FieldNumber_Topicality,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(GCVNEntityAnnotation__storage_, topicality),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "boundingPoly",
        .dataTypeSpecific.className = GPBStringifySymbol(GCVNBoundingPoly),
        .number = GCVNEntityAnnotation_FieldNumber_BoundingPoly,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(GCVNEntityAnnotation__storage_, boundingPoly),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "locationsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GCVNLocationInfo),
        .number = GCVNEntityAnnotation_FieldNumber_LocationsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GCVNEntityAnnotation__storage_, locationsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "propertiesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GCVNProperty),
        .number = GCVNEntityAnnotation_FieldNumber_PropertiesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GCVNEntityAnnotation__storage_, propertiesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCVNEntityAnnotation class]
                                     rootClass:[GCVNImageAnnotatorRoot class]
                                          file:GCVNImageAnnotatorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCVNEntityAnnotation__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GCVNLocalizedObjectAnnotation

@implementation GCVNLocalizedObjectAnnotation

@dynamic mid;
@dynamic languageCode;
@dynamic name;
@dynamic score;
@dynamic hasBoundingPoly, boundingPoly;

typedef struct GCVNLocalizedObjectAnnotation__storage_ {
  uint32_t _has_storage_[1];
  float score;
  NSString *mid;
  NSString *languageCode;
  NSString *name;
  GCVNBoundingPoly *boundingPoly;
} GCVNLocalizedObjectAnnotation__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "mid",
        .dataTypeSpecific.className = NULL,
        .number = GCVNLocalizedObjectAnnotation_FieldNumber_Mid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCVNLocalizedObjectAnnotation__storage_, mid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "languageCode",
        .dataTypeSpecific.className = NULL,
        .number = GCVNLocalizedObjectAnnotation_FieldNumber_LanguageCode,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GCVNLocalizedObjectAnnotation__storage_, languageCode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = GCVNLocalizedObjectAnnotation_FieldNumber_Name,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GCVNLocalizedObjectAnnotation__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "score",
        .dataTypeSpecific.className = NULL,
        .number = GCVNLocalizedObjectAnnotation_FieldNumber_Score,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GCVNLocalizedObjectAnnotation__storage_, score),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "boundingPoly",
        .dataTypeSpecific.className = GPBStringifySymbol(GCVNBoundingPoly),
        .number = GCVNLocalizedObjectAnnotation_FieldNumber_BoundingPoly,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GCVNLocalizedObjectAnnotation__storage_, boundingPoly),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCVNLocalizedObjectAnnotation class]
                                     rootClass:[GCVNImageAnnotatorRoot class]
                                          file:GCVNImageAnnotatorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCVNLocalizedObjectAnnotation__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GCVNSafeSearchAnnotation

@implementation GCVNSafeSearchAnnotation

@dynamic adult;
@dynamic spoof;
@dynamic medical;
@dynamic violence;
@dynamic racy;

typedef struct GCVNSafeSearchAnnotation__storage_ {
  uint32_t _has_storage_[1];
  GCVNLikelihood adult;
  GCVNLikelihood spoof;
  GCVNLikelihood medical;
  GCVNLikelihood violence;
  GCVNLikelihood racy;
} GCVNSafeSearchAnnotation__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "adult",
        .dataTypeSpecific.enumDescFunc = GCVNLikelihood_EnumDescriptor,
        .number = GCVNSafeSearchAnnotation_FieldNumber_Adult,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCVNSafeSearchAnnotation__storage_, adult),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "spoof",
        .dataTypeSpecific.enumDescFunc = GCVNLikelihood_EnumDescriptor,
        .number = GCVNSafeSearchAnnotation_FieldNumber_Spoof,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GCVNSafeSearchAnnotation__storage_, spoof),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "medical",
        .dataTypeSpecific.enumDescFunc = GCVNLikelihood_EnumDescriptor,
        .number = GCVNSafeSearchAnnotation_FieldNumber_Medical,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GCVNSafeSearchAnnotation__storage_, medical),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "violence",
        .dataTypeSpecific.enumDescFunc = GCVNLikelihood_EnumDescriptor,
        .number = GCVNSafeSearchAnnotation_FieldNumber_Violence,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GCVNSafeSearchAnnotation__storage_, violence),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "racy",
        .dataTypeSpecific.enumDescFunc = GCVNLikelihood_EnumDescriptor,
        .number = GCVNSafeSearchAnnotation_FieldNumber_Racy,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GCVNSafeSearchAnnotation__storage_, racy),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCVNSafeSearchAnnotation class]
                                     rootClass:[GCVNImageAnnotatorRoot class]
                                          file:GCVNImageAnnotatorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCVNSafeSearchAnnotation__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t GCVNSafeSearchAnnotation_Adult_RawValue(GCVNSafeSearchAnnotation *message) {
  GPBDescriptor *descriptor = [GCVNSafeSearchAnnotation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GCVNSafeSearchAnnotation_FieldNumber_Adult];
  return GPBGetMessageInt32Field(message, field);
}

void SetGCVNSafeSearchAnnotation_Adult_RawValue(GCVNSafeSearchAnnotation *message, int32_t value) {
  GPBDescriptor *descriptor = [GCVNSafeSearchAnnotation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GCVNSafeSearchAnnotation_FieldNumber_Adult];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t GCVNSafeSearchAnnotation_Spoof_RawValue(GCVNSafeSearchAnnotation *message) {
  GPBDescriptor *descriptor = [GCVNSafeSearchAnnotation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GCVNSafeSearchAnnotation_FieldNumber_Spoof];
  return GPBGetMessageInt32Field(message, field);
}

void SetGCVNSafeSearchAnnotation_Spoof_RawValue(GCVNSafeSearchAnnotation *message, int32_t value) {
  GPBDescriptor *descriptor = [GCVNSafeSearchAnnotation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GCVNSafeSearchAnnotation_FieldNumber_Spoof];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t GCVNSafeSearchAnnotation_Medical_RawValue(GCVNSafeSearchAnnotation *message) {
  GPBDescriptor *descriptor = [GCVNSafeSearchAnnotation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GCVNSafeSearchAnnotation_FieldNumber_Medical];
  return GPBGetMessageInt32Field(message, field);
}

void SetGCVNSafeSearchAnnotation_Medical_RawValue(GCVNSafeSearchAnnotation *message, int32_t value) {
  GPBDescriptor *descriptor = [GCVNSafeSearchAnnotation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GCVNSafeSearchAnnotation_FieldNumber_Medical];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t GCVNSafeSearchAnnotation_Violence_RawValue(GCVNSafeSearchAnnotation *message) {
  GPBDescriptor *descriptor = [GCVNSafeSearchAnnotation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GCVNSafeSearchAnnotation_FieldNumber_Violence];
  return GPBGetMessageInt32Field(message, field);
}

void SetGCVNSafeSearchAnnotation_Violence_RawValue(GCVNSafeSearchAnnotation *message, int32_t value) {
  GPBDescriptor *descriptor = [GCVNSafeSearchAnnotation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GCVNSafeSearchAnnotation_FieldNumber_Violence];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t GCVNSafeSearchAnnotation_Racy_RawValue(GCVNSafeSearchAnnotation *message) {
  GPBDescriptor *descriptor = [GCVNSafeSearchAnnotation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GCVNSafeSearchAnnotation_FieldNumber_Racy];
  return GPBGetMessageInt32Field(message, field);
}

void SetGCVNSafeSearchAnnotation_Racy_RawValue(GCVNSafeSearchAnnotation *message, int32_t value) {
  GPBDescriptor *descriptor = [GCVNSafeSearchAnnotation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GCVNSafeSearchAnnotation_FieldNumber_Racy];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - GCVNLatLongRect

@implementation GCVNLatLongRect

@dynamic hasMinLatLng, minLatLng;
@dynamic hasMaxLatLng, maxLatLng;

typedef struct GCVNLatLongRect__storage_ {
  uint32_t _has_storage_[1];
  GTPLatLng *minLatLng;
  GTPLatLng *maxLatLng;
} GCVNLatLongRect__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "minLatLng",
        .dataTypeSpecific.className = GPBStringifySymbol(GTPLatLng),
        .number = GCVNLatLongRect_FieldNumber_MinLatLng,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCVNLatLongRect__storage_, minLatLng),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "maxLatLng",
        .dataTypeSpecific.className = GPBStringifySymbol(GTPLatLng),
        .number = GCVNLatLongRect_FieldNumber_MaxLatLng,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GCVNLatLongRect__storage_, maxLatLng),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCVNLatLongRect class]
                                     rootClass:[GCVNImageAnnotatorRoot class]
                                          file:GCVNImageAnnotatorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCVNLatLongRect__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GCVNColorInfo

@implementation GCVNColorInfo

@dynamic hasColor, color;
@dynamic score;
@dynamic pixelFraction;

typedef struct GCVNColorInfo__storage_ {
  uint32_t _has_storage_[1];
  float score;
  float pixelFraction;
  GTPColor *color;
} GCVNColorInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "color",
        .dataTypeSpecific.className = GPBStringifySymbol(GTPColor),
        .number = GCVNColorInfo_FieldNumber_Color,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCVNColorInfo__storage_, color),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "score",
        .dataTypeSpecific.className = NULL,
        .number = GCVNColorInfo_FieldNumber_Score,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GCVNColorInfo__storage_, score),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "pixelFraction",
        .dataTypeSpecific.className = NULL,
        .number = GCVNColorInfo_FieldNumber_PixelFraction,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GCVNColorInfo__storage_, pixelFraction),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCVNColorInfo class]
                                     rootClass:[GCVNImageAnnotatorRoot class]
                                          file:GCVNImageAnnotatorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCVNColorInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GCVNDominantColorsAnnotation

@implementation GCVNDominantColorsAnnotation

@dynamic colorsArray, colorsArray_Count;

typedef struct GCVNDominantColorsAnnotation__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *colorsArray;
} GCVNDominantColorsAnnotation__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "colorsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GCVNColorInfo),
        .number = GCVNDominantColorsAnnotation_FieldNumber_ColorsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GCVNDominantColorsAnnotation__storage_, colorsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCVNDominantColorsAnnotation class]
                                     rootClass:[GCVNImageAnnotatorRoot class]
                                          file:GCVNImageAnnotatorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCVNDominantColorsAnnotation__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GCVNImageProperties

@implementation GCVNImageProperties

@dynamic hasDominantColors, dominantColors;

typedef struct GCVNImageProperties__storage_ {
  uint32_t _has_storage_[1];
  GCVNDominantColorsAnnotation *dominantColors;
} GCVNImageProperties__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dominantColors",
        .dataTypeSpecific.className = GPBStringifySymbol(GCVNDominantColorsAnnotation),
        .number = GCVNImageProperties_FieldNumber_DominantColors,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCVNImageProperties__storage_, dominantColors),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCVNImageProperties class]
                                     rootClass:[GCVNImageAnnotatorRoot class]
                                          file:GCVNImageAnnotatorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCVNImageProperties__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GCVNCropHint

@implementation GCVNCropHint

@dynamic hasBoundingPoly, boundingPoly;
@dynamic confidence;
@dynamic importanceFraction;

typedef struct GCVNCropHint__storage_ {
  uint32_t _has_storage_[1];
  float confidence;
  float importanceFraction;
  GCVNBoundingPoly *boundingPoly;
} GCVNCropHint__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "boundingPoly",
        .dataTypeSpecific.className = GPBStringifySymbol(GCVNBoundingPoly),
        .number = GCVNCropHint_FieldNumber_BoundingPoly,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCVNCropHint__storage_, boundingPoly),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "confidence",
        .dataTypeSpecific.className = NULL,
        .number = GCVNCropHint_FieldNumber_Confidence,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GCVNCropHint__storage_, confidence),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "importanceFraction",
        .dataTypeSpecific.className = NULL,
        .number = GCVNCropHint_FieldNumber_ImportanceFraction,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GCVNCropHint__storage_, importanceFraction),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCVNCropHint class]
                                     rootClass:[GCVNImageAnnotatorRoot class]
                                          file:GCVNImageAnnotatorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCVNCropHint__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GCVNCropHintsAnnotation

@implementation GCVNCropHintsAnnotation

@dynamic cropHintsArray, cropHintsArray_Count;

typedef struct GCVNCropHintsAnnotation__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *cropHintsArray;
} GCVNCropHintsAnnotation__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "cropHintsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GCVNCropHint),
        .number = GCVNCropHintsAnnotation_FieldNumber_CropHintsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GCVNCropHintsAnnotation__storage_, cropHintsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCVNCropHintsAnnotation class]
                                     rootClass:[GCVNImageAnnotatorRoot class]
                                          file:GCVNImageAnnotatorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCVNCropHintsAnnotation__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GCVNCropHintsParams

@implementation GCVNCropHintsParams

@dynamic aspectRatiosArray, aspectRatiosArray_Count;

typedef struct GCVNCropHintsParams__storage_ {
  uint32_t _has_storage_[1];
  GPBFloatArray *aspectRatiosArray;
} GCVNCropHintsParams__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "aspectRatiosArray",
        .dataTypeSpecific.className = NULL,
        .number = GCVNCropHintsParams_FieldNumber_AspectRatiosArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GCVNCropHintsParams__storage_, aspectRatiosArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeFloat,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCVNCropHintsParams class]
                                     rootClass:[GCVNImageAnnotatorRoot class]
                                          file:GCVNImageAnnotatorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCVNCropHintsParams__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GCVNWebDetectionParams

@implementation GCVNWebDetectionParams

@dynamic includeGeoResults;

typedef struct GCVNWebDetectionParams__storage_ {
  uint32_t _has_storage_[1];
} GCVNWebDetectionParams__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "includeGeoResults",
        .dataTypeSpecific.className = NULL,
        .number = GCVNWebDetectionParams_FieldNumber_IncludeGeoResults,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCVNWebDetectionParams class]
                                     rootClass:[GCVNImageAnnotatorRoot class]
                                          file:GCVNImageAnnotatorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCVNWebDetectionParams__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GCVNImageContext

@implementation GCVNImageContext

@dynamic hasLatLongRect, latLongRect;
@dynamic languageHintsArray, languageHintsArray_Count;
@dynamic hasCropHintsParams, cropHintsParams;
@dynamic hasProductSearchParams, productSearchParams;
@dynamic hasWebDetectionParams, webDetectionParams;

typedef struct GCVNImageContext__storage_ {
  uint32_t _has_storage_[1];
  GCVNLatLongRect *latLongRect;
  NSMutableArray *languageHintsArray;
  GCVNCropHintsParams *cropHintsParams;
  GCVNProductSearchParams *productSearchParams;
  GCVNWebDetectionParams *webDetectionParams;
} GCVNImageContext__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "latLongRect",
        .dataTypeSpecific.className = GPBStringifySymbol(GCVNLatLongRect),
        .number = GCVNImageContext_FieldNumber_LatLongRect,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCVNImageContext__storage_, latLongRect),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "languageHintsArray",
        .dataTypeSpecific.className = NULL,
        .number = GCVNImageContext_FieldNumber_LanguageHintsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GCVNImageContext__storage_, languageHintsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cropHintsParams",
        .dataTypeSpecific.className = GPBStringifySymbol(GCVNCropHintsParams),
        .number = GCVNImageContext_FieldNumber_CropHintsParams,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GCVNImageContext__storage_, cropHintsParams),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "productSearchParams",
        .dataTypeSpecific.className = GPBStringifySymbol(GCVNProductSearchParams),
        .number = GCVNImageContext_FieldNumber_ProductSearchParams,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GCVNImageContext__storage_, productSearchParams),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "webDetectionParams",
        .dataTypeSpecific.className = GPBStringifySymbol(GCVNWebDetectionParams),
        .number = GCVNImageContext_FieldNumber_WebDetectionParams,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GCVNImageContext__storage_, webDetectionParams),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCVNImageContext class]
                                     rootClass:[GCVNImageAnnotatorRoot class]
                                          file:GCVNImageAnnotatorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCVNImageContext__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GCVNAnnotateImageRequest

@implementation GCVNAnnotateImageRequest

@dynamic hasImage, image;
@dynamic featuresArray, featuresArray_Count;
@dynamic hasImageContext, imageContext;

typedef struct GCVNAnnotateImageRequest__storage_ {
  uint32_t _has_storage_[1];
  GCVNImage *image;
  NSMutableArray *featuresArray;
  GCVNImageContext *imageContext;
} GCVNAnnotateImageRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "image",
        .dataTypeSpecific.className = GPBStringifySymbol(GCVNImage),
        .number = GCVNAnnotateImageRequest_FieldNumber_Image,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCVNAnnotateImageRequest__storage_, image),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "featuresArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GCVNFeature),
        .number = GCVNAnnotateImageRequest_FieldNumber_FeaturesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GCVNAnnotateImageRequest__storage_, featuresArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "imageContext",
        .dataTypeSpecific.className = GPBStringifySymbol(GCVNImageContext),
        .number = GCVNAnnotateImageRequest_FieldNumber_ImageContext,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GCVNAnnotateImageRequest__storage_, imageContext),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCVNAnnotateImageRequest class]
                                     rootClass:[GCVNImageAnnotatorRoot class]
                                          file:GCVNImageAnnotatorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCVNAnnotateImageRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GCVNImageAnnotationContext

@implementation GCVNImageAnnotationContext

@dynamic uri;
@dynamic pageNumber;

typedef struct GCVNImageAnnotationContext__storage_ {
  uint32_t _has_storage_[1];
  int32_t pageNumber;
  NSString *uri;
} GCVNImageAnnotationContext__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uri",
        .dataTypeSpecific.className = NULL,
        .number = GCVNImageAnnotationContext_FieldNumber_Uri,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCVNImageAnnotationContext__storage_, uri),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pageNumber",
        .dataTypeSpecific.className = NULL,
        .number = GCVNImageAnnotationContext_FieldNumber_PageNumber,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GCVNImageAnnotationContext__storage_, pageNumber),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCVNImageAnnotationContext class]
                                     rootClass:[GCVNImageAnnotatorRoot class]
                                          file:GCVNImageAnnotatorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCVNImageAnnotationContext__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GCVNAnnotateImageResponse

@implementation GCVNAnnotateImageResponse

@dynamic faceAnnotationsArray, faceAnnotationsArray_Count;
@dynamic landmarkAnnotationsArray, landmarkAnnotationsArray_Count;
@dynamic logoAnnotationsArray, logoAnnotationsArray_Count;
@dynamic labelAnnotationsArray, labelAnnotationsArray_Count;
@dynamic localizedObjectAnnotationsArray, localizedObjectAnnotationsArray_Count;
@dynamic textAnnotationsArray, textAnnotationsArray_Count;
@dynamic hasFullTextAnnotation, fullTextAnnotation;
@dynamic hasSafeSearchAnnotation, safeSearchAnnotation;
@dynamic hasImagePropertiesAnnotation, imagePropertiesAnnotation;
@dynamic hasCropHintsAnnotation, cropHintsAnnotation;
@dynamic hasWebDetection, webDetection;
@dynamic hasProductSearchResults, productSearchResults;
@dynamic hasError, error;
@dynamic hasContext, context;

typedef struct GCVNAnnotateImageResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *faceAnnotationsArray;
  NSMutableArray *landmarkAnnotationsArray;
  NSMutableArray *logoAnnotationsArray;
  NSMutableArray *labelAnnotationsArray;
  NSMutableArray *textAnnotationsArray;
  GCVNSafeSearchAnnotation *safeSearchAnnotation;
  GCVNImageProperties *imagePropertiesAnnotation;
  Status *error;
  GCVNCropHintsAnnotation *cropHintsAnnotation;
  GCVNTextAnnotation *fullTextAnnotation;
  GCVNWebDetection *webDetection;
  GCVNProductSearchResults *productSearchResults;
  GCVNImageAnnotationContext *context;
  NSMutableArray *localizedObjectAnnotationsArray;
} GCVNAnnotateImageResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "faceAnnotationsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GCVNFaceAnnotation),
        .number = GCVNAnnotateImageResponse_FieldNumber_FaceAnnotationsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GCVNAnnotateImageResponse__storage_, faceAnnotationsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "landmarkAnnotationsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GCVNEntityAnnotation),
        .number = GCVNAnnotateImageResponse_FieldNumber_LandmarkAnnotationsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GCVNAnnotateImageResponse__storage_, landmarkAnnotationsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "logoAnnotationsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GCVNEntityAnnotation),
        .number = GCVNAnnotateImageResponse_FieldNumber_LogoAnnotationsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GCVNAnnotateImageResponse__storage_, logoAnnotationsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "labelAnnotationsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GCVNEntityAnnotation),
        .number = GCVNAnnotateImageResponse_FieldNumber_LabelAnnotationsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GCVNAnnotateImageResponse__storage_, labelAnnotationsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "textAnnotationsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GCVNEntityAnnotation),
        .number = GCVNAnnotateImageResponse_FieldNumber_TextAnnotationsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GCVNAnnotateImageResponse__storage_, textAnnotationsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "safeSearchAnnotation",
        .dataTypeSpecific.className = GPBStringifySymbol(GCVNSafeSearchAnnotation),
        .number = GCVNAnnotateImageResponse_FieldNumber_SafeSearchAnnotation,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GCVNAnnotateImageResponse__storage_, safeSearchAnnotation),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "imagePropertiesAnnotation",
        .dataTypeSpecific.className = GPBStringifySymbol(GCVNImageProperties),
        .number = GCVNAnnotateImageResponse_FieldNumber_ImagePropertiesAnnotation,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GCVNAnnotateImageResponse__storage_, imagePropertiesAnnotation),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "error",
        .dataTypeSpecific.className = GPBStringifySymbol(Status),
        .number = GCVNAnnotateImageResponse_FieldNumber_Error,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(GCVNAnnotateImageResponse__storage_, error),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "cropHintsAnnotation",
        .dataTypeSpecific.className = GPBStringifySymbol(GCVNCropHintsAnnotation),
        .number = GCVNAnnotateImageResponse_FieldNumber_CropHintsAnnotation,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GCVNAnnotateImageResponse__storage_, cropHintsAnnotation),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "fullTextAnnotation",
        .dataTypeSpecific.className = GPBStringifySymbol(GCVNTextAnnotation),
        .number = GCVNAnnotateImageResponse_FieldNumber_FullTextAnnotation,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCVNAnnotateImageResponse__storage_, fullTextAnnotation),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "webDetection",
        .dataTypeSpecific.className = GPBStringifySymbol(GCVNWebDetection),
        .number = GCVNAnnotateImageResponse_FieldNumber_WebDetection,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GCVNAnnotateImageResponse__storage_, webDetection),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "productSearchResults",
        .dataTypeSpecific.className = GPBStringifySymbol(GCVNProductSearchResults),
        .number = GCVNAnnotateImageResponse_FieldNumber_ProductSearchResults,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(GCVNAnnotateImageResponse__storage_, productSearchResults),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "context",
        .dataTypeSpecific.className = GPBStringifySymbol(GCVNImageAnnotationContext),
        .number = GCVNAnnotateImageResponse_FieldNumber_Context,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(GCVNAnnotateImageResponse__storage_, context),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "localizedObjectAnnotationsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GCVNLocalizedObjectAnnotation),
        .number = GCVNAnnotateImageResponse_FieldNumber_LocalizedObjectAnnotationsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GCVNAnnotateImageResponse__storage_, localizedObjectAnnotationsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCVNAnnotateImageResponse class]
                                     rootClass:[GCVNImageAnnotatorRoot class]
                                          file:GCVNImageAnnotatorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCVNAnnotateImageResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GCVNAnnotateFileResponse

@implementation GCVNAnnotateFileResponse

@dynamic hasInputConfig, inputConfig;
@dynamic responsesArray, responsesArray_Count;

typedef struct GCVNAnnotateFileResponse__storage_ {
  uint32_t _has_storage_[1];
  GCVNInputConfig *inputConfig;
  NSMutableArray *responsesArray;
} GCVNAnnotateFileResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "inputConfig",
        .dataTypeSpecific.className = GPBStringifySymbol(GCVNInputConfig),
        .number = GCVNAnnotateFileResponse_FieldNumber_InputConfig,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCVNAnnotateFileResponse__storage_, inputConfig),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "responsesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GCVNAnnotateImageResponse),
        .number = GCVNAnnotateFileResponse_FieldNumber_ResponsesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GCVNAnnotateFileResponse__storage_, responsesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCVNAnnotateFileResponse class]
                                     rootClass:[GCVNImageAnnotatorRoot class]
                                          file:GCVNImageAnnotatorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCVNAnnotateFileResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GCVNBatchAnnotateImagesRequest

@implementation GCVNBatchAnnotateImagesRequest

@dynamic requestsArray, requestsArray_Count;

typedef struct GCVNBatchAnnotateImagesRequest__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *requestsArray;
} GCVNBatchAnnotateImagesRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "requestsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GCVNAnnotateImageRequest),
        .number = GCVNBatchAnnotateImagesRequest_FieldNumber_RequestsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GCVNBatchAnnotateImagesRequest__storage_, requestsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCVNBatchAnnotateImagesRequest class]
                                     rootClass:[GCVNImageAnnotatorRoot class]
                                          file:GCVNImageAnnotatorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCVNBatchAnnotateImagesRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GCVNBatchAnnotateImagesResponse

@implementation GCVNBatchAnnotateImagesResponse

@dynamic responsesArray, responsesArray_Count;

typedef struct GCVNBatchAnnotateImagesResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *responsesArray;
} GCVNBatchAnnotateImagesResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "responsesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GCVNAnnotateImageResponse),
        .number = GCVNBatchAnnotateImagesResponse_FieldNumber_ResponsesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GCVNBatchAnnotateImagesResponse__storage_, responsesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCVNBatchAnnotateImagesResponse class]
                                     rootClass:[GCVNImageAnnotatorRoot class]
                                          file:GCVNImageAnnotatorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCVNBatchAnnotateImagesResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GCVNAsyncAnnotateFileRequest

@implementation GCVNAsyncAnnotateFileRequest

@dynamic hasInputConfig, inputConfig;
@dynamic featuresArray, featuresArray_Count;
@dynamic hasImageContext, imageContext;
@dynamic hasOutputConfig, outputConfig;

typedef struct GCVNAsyncAnnotateFileRequest__storage_ {
  uint32_t _has_storage_[1];
  GCVNInputConfig *inputConfig;
  NSMutableArray *featuresArray;
  GCVNImageContext *imageContext;
  GCVNOutputConfig *outputConfig;
} GCVNAsyncAnnotateFileRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "inputConfig",
        .dataTypeSpecific.className = GPBStringifySymbol(GCVNInputConfig),
        .number = GCVNAsyncAnnotateFileRequest_FieldNumber_InputConfig,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCVNAsyncAnnotateFileRequest__storage_, inputConfig),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "featuresArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GCVNFeature),
        .number = GCVNAsyncAnnotateFileRequest_FieldNumber_FeaturesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GCVNAsyncAnnotateFileRequest__storage_, featuresArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "imageContext",
        .dataTypeSpecific.className = GPBStringifySymbol(GCVNImageContext),
        .number = GCVNAsyncAnnotateFileRequest_FieldNumber_ImageContext,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GCVNAsyncAnnotateFileRequest__storage_, imageContext),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "outputConfig",
        .dataTypeSpecific.className = GPBStringifySymbol(GCVNOutputConfig),
        .number = GCVNAsyncAnnotateFileRequest_FieldNumber_OutputConfig,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GCVNAsyncAnnotateFileRequest__storage_, outputConfig),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCVNAsyncAnnotateFileRequest class]
                                     rootClass:[GCVNImageAnnotatorRoot class]
                                          file:GCVNImageAnnotatorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCVNAsyncAnnotateFileRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GCVNAsyncAnnotateFileResponse

@implementation GCVNAsyncAnnotateFileResponse

@dynamic hasOutputConfig, outputConfig;

typedef struct GCVNAsyncAnnotateFileResponse__storage_ {
  uint32_t _has_storage_[1];
  GCVNOutputConfig *outputConfig;
} GCVNAsyncAnnotateFileResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "outputConfig",
        .dataTypeSpecific.className = GPBStringifySymbol(GCVNOutputConfig),
        .number = GCVNAsyncAnnotateFileResponse_FieldNumber_OutputConfig,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCVNAsyncAnnotateFileResponse__storage_, outputConfig),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCVNAsyncAnnotateFileResponse class]
                                     rootClass:[GCVNImageAnnotatorRoot class]
                                          file:GCVNImageAnnotatorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCVNAsyncAnnotateFileResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GCVNAsyncBatchAnnotateFilesRequest

@implementation GCVNAsyncBatchAnnotateFilesRequest

@dynamic requestsArray, requestsArray_Count;

typedef struct GCVNAsyncBatchAnnotateFilesRequest__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *requestsArray;
} GCVNAsyncBatchAnnotateFilesRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "requestsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GCVNAsyncAnnotateFileRequest),
        .number = GCVNAsyncBatchAnnotateFilesRequest_FieldNumber_RequestsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GCVNAsyncBatchAnnotateFilesRequest__storage_, requestsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCVNAsyncBatchAnnotateFilesRequest class]
                                     rootClass:[GCVNImageAnnotatorRoot class]
                                          file:GCVNImageAnnotatorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCVNAsyncBatchAnnotateFilesRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GCVNAsyncBatchAnnotateFilesResponse

@implementation GCVNAsyncBatchAnnotateFilesResponse

@dynamic responsesArray, responsesArray_Count;

typedef struct GCVNAsyncBatchAnnotateFilesResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *responsesArray;
} GCVNAsyncBatchAnnotateFilesResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "responsesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GCVNAsyncAnnotateFileResponse),
        .number = GCVNAsyncBatchAnnotateFilesResponse_FieldNumber_ResponsesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GCVNAsyncBatchAnnotateFilesResponse__storage_, responsesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCVNAsyncBatchAnnotateFilesResponse class]
                                     rootClass:[GCVNImageAnnotatorRoot class]
                                          file:GCVNImageAnnotatorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCVNAsyncBatchAnnotateFilesResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GCVNInputConfig

@implementation GCVNInputConfig

@dynamic hasGcsSource, gcsSource;
@dynamic mimeType;

typedef struct GCVNInputConfig__storage_ {
  uint32_t _has_storage_[1];
  GCVNGcsSource *gcsSource;
  NSString *mimeType;
} GCVNInputConfig__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "gcsSource",
        .dataTypeSpecific.className = GPBStringifySymbol(GCVNGcsSource),
        .number = GCVNInputConfig_FieldNumber_GcsSource,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCVNInputConfig__storage_, gcsSource),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "mimeType",
        .dataTypeSpecific.className = NULL,
        .number = GCVNInputConfig_FieldNumber_MimeType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GCVNInputConfig__storage_, mimeType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCVNInputConfig class]
                                     rootClass:[GCVNImageAnnotatorRoot class]
                                          file:GCVNImageAnnotatorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCVNInputConfig__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GCVNOutputConfig

@implementation GCVNOutputConfig

@dynamic hasGcsDestination, gcsDestination;
@dynamic batchSize;

typedef struct GCVNOutputConfig__storage_ {
  uint32_t _has_storage_[1];
  int32_t batchSize;
  GCVNGcsDestination *gcsDestination;
} GCVNOutputConfig__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "gcsDestination",
        .dataTypeSpecific.className = GPBStringifySymbol(GCVNGcsDestination),
        .number = GCVNOutputConfig_FieldNumber_GcsDestination,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCVNOutputConfig__storage_, gcsDestination),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "batchSize",
        .dataTypeSpecific.className = NULL,
        .number = GCVNOutputConfig_FieldNumber_BatchSize,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GCVNOutputConfig__storage_, batchSize),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCVNOutputConfig class]
                                     rootClass:[GCVNImageAnnotatorRoot class]
                                          file:GCVNImageAnnotatorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCVNOutputConfig__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GCVNGcsSource

@implementation GCVNGcsSource

@dynamic uri;

typedef struct GCVNGcsSource__storage_ {
  uint32_t _has_storage_[1];
  NSString *uri;
} GCVNGcsSource__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uri",
        .dataTypeSpecific.className = NULL,
        .number = GCVNGcsSource_FieldNumber_Uri,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCVNGcsSource__storage_, uri),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCVNGcsSource class]
                                     rootClass:[GCVNImageAnnotatorRoot class]
                                          file:GCVNImageAnnotatorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCVNGcsSource__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GCVNGcsDestination

@implementation GCVNGcsDestination

@dynamic uri;

typedef struct GCVNGcsDestination__storage_ {
  uint32_t _has_storage_[1];
  NSString *uri;
} GCVNGcsDestination__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uri",
        .dataTypeSpecific.className = NULL,
        .number = GCVNGcsDestination_FieldNumber_Uri,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCVNGcsDestination__storage_, uri),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCVNGcsDestination class]
                                     rootClass:[GCVNImageAnnotatorRoot class]
                                          file:GCVNImageAnnotatorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCVNGcsDestination__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GCVNOperationMetadata

@implementation GCVNOperationMetadata

@dynamic state;
@dynamic hasCreateTime, createTime;
@dynamic hasUpdateTime, updateTime;

typedef struct GCVNOperationMetadata__storage_ {
  uint32_t _has_storage_[1];
  GCVNOperationMetadata_State state;
  GPBTimestamp *createTime;
  GPBTimestamp *updateTime;
} GCVNOperationMetadata__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "state",
        .dataTypeSpecific.enumDescFunc = GCVNOperationMetadata_State_EnumDescriptor,
        .number = GCVNOperationMetadata_FieldNumber_State,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GCVNOperationMetadata__storage_, state),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "createTime",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBTimestamp),
        .number = GCVNOperationMetadata_FieldNumber_CreateTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GCVNOperationMetadata__storage_, createTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "updateTime",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBTimestamp),
        .number = GCVNOperationMetadata_FieldNumber_UpdateTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GCVNOperationMetadata__storage_, updateTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GCVNOperationMetadata class]
                                     rootClass:[GCVNImageAnnotatorRoot class]
                                          file:GCVNImageAnnotatorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GCVNOperationMetadata__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t GCVNOperationMetadata_State_RawValue(GCVNOperationMetadata *message) {
  GPBDescriptor *descriptor = [GCVNOperationMetadata descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GCVNOperationMetadata_FieldNumber_State];
  return GPBGetMessageInt32Field(message, field);
}

void SetGCVNOperationMetadata_State_RawValue(GCVNOperationMetadata *message, int32_t value) {
  GPBDescriptor *descriptor = [GCVNOperationMetadata descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:GCVNOperationMetadata_FieldNumber_State];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum GCVNOperationMetadata_State

GPBEnumDescriptor *GCVNOperationMetadata_State_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "StateUnspecified\000Created\000Running\000Done\000Ca"
        "ncelled\000";
    static const int32_t values[] = {
        GCVNOperationMetadata_State_StateUnspecified,
        GCVNOperationMetadata_State_Created,
        GCVNOperationMetadata_State_Running,
        GCVNOperationMetadata_State_Done,
        GCVNOperationMetadata_State_Cancelled,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(GCVNOperationMetadata_State)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:GCVNOperationMetadata_State_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL GCVNOperationMetadata_State_IsValidValue(int32_t value__) {
  switch (value__) {
    case GCVNOperationMetadata_State_StateUnspecified:
    case GCVNOperationMetadata_State_Created:
    case GCVNOperationMetadata_State_Running:
    case GCVNOperationMetadata_State_Done:
    case GCVNOperationMetadata_State_Cancelled:
      return YES;
    default:
      return NO;
  }
}


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
